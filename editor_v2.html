<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Python Editor + Realtime Coach + Test</title>

  <style>
    :root{
      --bg:#f3f5f8; --card:#fff; --border:#e6eaf0; --muted:#667085; --text:#101828;
      --out-bg:#0b1220; --out-text:#e6f2ff; --out-muted:#9bb4d0; --danger:#ff4d4f; --ok:#2ecc71;
      --btn:#1677ff; --btn-hover:#0f63d6; --btn2:#e9f2ff; --btn2-text:#0b5ed7;
      --coach-accent:#0b5ed7; --coach-soft:#eef6ff;
      --stmt-bg:#ffffff;
      --stmt-border:#dbeafe;
      --stmt-title:#0b5ed7;

      /* Layout tuning (responsive) */
      /*
        ∆Øu ti√™n v√πng code cao h∆°n:
        - Khung Input/Output g·ªçn l·∫°i ƒë·ªÉ HS nh√¨n editor ƒë∆∞·ª£c nhi·ªÅu h∆°n.
        - V·∫´n gi·ªØ ƒë·ªß kh√¥ng gian ƒë·ªÉ cu·ªôn xem output khi c·∫ßn.
      */
      --bottom-min:140px; /* chi·ªÅu cao t·ªëi thi·ªÉu khung I/O */
      --bottom-max:20vh;  /* chi·ªÅu cao t·ªëi ƒëa khung I/O (t√≠nh theo viewport height) */
      --editor-min:180px; /* chi·ªÅu cao t·ªëi thi·ªÉu v√πng code */
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:var(--text); overflow:hidden; }
    .page{
  height:100%;
  max-width:1200px;
  margin:0 auto;
  padding:12px 14px;
  display:grid;
  grid-template-rows: 1fr minmax(min(var(--bottom-min), var(--bottom-max)), var(--bottom-max));
  gap:12px;
}
/* Cho ph√©p flex/grid con co l·∫°i ƒë√∫ng (tr√°nh tr√†n chi·ªÅu cao) */
.page > *{ min-height:0; }
    .editor-card{ background:var(--card); border:1px solid var(--border); border-radius:14px; overflow:hidden; box-shadow:0 8px 22px rgba(16,24,40,.06); display:flex; flex-direction:column; min-height:0; }

    .editor-toolbar{
      display:flex; align-items:center; justify-content:flex-start;
      padding:8px 12px; border-bottom:1px solid var(--border); background:#fff;
      gap:10px;
      flex-wrap:nowrap;
      overflow-x:auto;
      -webkit-overflow-scrolling:touch;
    }
    .toolbar-left{ display:flex; align-items:center; gap:10px; min-width:200px; flex:0 1 320px; }
    .dot{ width:10px;height:10px;border-radius:50%; background:#d0d5dd; }
    .title{ font-weight:900; font-size:14px; }
    .sub{ font-size:12px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:520px; }
    /*
      Toolbar layout fix:
      - Tr√°nh hi·ªán t∆∞·ª£ng ch·ªØ "Test: x/y" ƒë√® l√™n "S·∫µn s√†ng" khi thi·∫øu chi·ªÅu ngang.
      - Gi·ªØ giao di·ªán ƒë·ªìng b·ªô tr∆∞·ªõc/sau khi b·∫•m Test (k·ªÉ c·∫£ khi hi·ªán n√∫t "B√†i ti·∫øp theo").
    */
    .toolbar-mid{ display:flex; align-items:center; gap:10px; flex:1 1 auto; min-width:0; flex-wrap:nowrap; }
/* Pretest bar (hi·ªán khi b√†i b·ªã kh√≥a b·ªüi √¥n luy·ªán b·∫Øt bu·ªôc) */
.pretestRow{
  display:none;
  justify-content:center;
  padding:6px 12px;
  border-bottom:1px solid var(--border);
  background:#fff;
}
    select{ width:100%; max-width:520px; padding:9px 10px; border-radius:10px; border:1px solid var(--border); background:#fff; font-size:13px; outline:none; }
    /*
      ƒê∆∞a c·ª•m n√∫t h√†nh ƒë·ªông xu·ªëng 1 d√≤ng ri√™ng ƒë·ªÉ:
      - Kh√¥ng che ph·∫ßn ch·ªçn "B√†i nh·ªè"
      - Kh√¥ng b·ªã thay ƒë·ªïi layout khi n√∫t "B√†i ti·∫øp theo" xu·∫•t hi·ªán
    */
    .toolbar-right{ display:flex; align-items:center; gap:10px; flex-wrap:nowrap; min-width:0; flex:0 0 auto; margin-left:auto; }

    /* PASS/FAIL + Test counter: lu√¥n n·∫±m g·ªçn trong toolbar-mid */
    #pill{ margin-left:auto; }
    #scoreMeta{ white-space:nowrap; }

    /* N√∫t "B√†i ti·∫øp theo" g·ªçn h∆°n ƒë·ªÉ kh√¥ng chi·∫øm ngang qu√° nhi·ªÅu */
    #nextBtn{ padding:8px 10px; font-size:12px; }

    .btn{ border:0; background:var(--btn); color:#fff; padding:9px 14px; border-radius:10px; cursor:pointer; font-weight:900; font-size:13px; }
    .btn:hover{ background:var(--btn-hover); }
    .btn2{ border:1px solid #cfe3ff; background:var(--btn2); color:var(--btn2-text); padding:9px 14px; border-radius:10px; cursor:pointer; font-weight:900; font-size:13px; }

    /* Toolbar: co g·ªçn tr√™n m√†n h√¨nh h·∫πp ƒë·ªÉ b·ªõt chi·∫øm chi·ªÅu cao */
    @media (max-width: 640px){
      .editor-toolbar{ padding:6px 10px; gap:8px; }
      .toolbar-right{ display:flex; align-items:center; gap:10px; flex-wrap:nowrap; min-width:0; flex:0 0 auto; margin-left:auto; }
      .btn, .btn2, .miniTag, .pretestBtn{ padding:8px 10px; font-size:12px; }
      .sub{ max-width:340px; }
    }

    .status{ font-size:12px; color:var(--muted); white-space:nowrap; }
    #status{ max-width:140px; overflow:hidden; text-overflow:ellipsis; }

    .pill{ display:inline-block; padding:3px 10px; border-radius:999px; font-size:12px; font-weight:900; background:#eef2ff; color:#344054; border:1px solid var(--border); }
    .pill.ok{ background:#e9fff0; color:#0a7a2a; border-color:#bff0cd; }
    .pill.bad{ background:#ffecec; color:#b00020; border-color:#ffb7b7; }

    /* ƒê·ªÅ b√†i */
    .statementbar{ padding:10px 12px; border-bottom:1px solid var(--border); background:#fff; }
    .statementbox{ background:var(--stmt-bg); border:2px solid var(--stmt-border); border-radius:14px; padding:14px 14px; }
    .statementtitle{ font-weight:1000; font-size:18px; color:var(--stmt-title); margin:0 0 8px 0; line-height:1.2; }
    .statementtext{ margin:0; font-size:16px; line-height:1.55; white-space:pre-wrap; color:#123b63; max-height:120px; overflow:auto; }

    /* Coach */
    .coachbar{ padding:8px 12px; border-bottom:1px solid var(--border); background:#fff; display:flex; gap:10px; align-items:flex-start; }
    .coach-left{ flex:1 1 auto; min-width:220px; }
    .coach-title{ font-size:12px; font-weight:900; color:var(--coach-accent); margin-bottom:6px; }
    .coach-next{ font-size:12px; line-height:1.35; background:var(--coach-soft); border:1px solid #d9ebff; padding:8px 10px; border-radius:10px; white-space:pre-wrap; color:#123b63; max-height:90px; overflow:auto; }
    .coach-right{ flex:0 0 360px; max-width:420px; background:#fff; border:1px solid var(--border); border-radius:12px; padding:8px 10px; max-height:132px; overflow:auto; }
    .checklist{ margin:0; padding-left:18px; font-size:12px; color:#123b63; line-height:1.55; }
    .checklist .ok{ color:#0a7a2a; font-weight:900; } .checklist .no{ color:#b00020; font-weight:900; }
    @media (max-width: 920px){ .coachbar{ flex-direction:column; } .coach-right{ width:100%; max-width:none; } }

    /* Monaco */
    .code-wrap{ flex:1 1 auto; min-height:var(--editor-min); position:relative; background:#fff; }
    @media (max-width: 920px){ .statementtext{ max-height:96px; } .coach-next{ max-height:78px; } .coach-right{ max-height:120px; } }

    /* ===== Responsive theo chi·ªÅu cao (m√†n h√¨nh th·∫•p) =====
       M·ª•c ti√™u: kh√¥ng ƒë·ªÉ v√πng code b·ªã "√©p" qu√° nh·ªè tr√™n laptop m√†n h√¨nh th·∫•p. */
    @media (max-height: 820px){
      :root{ --bottom-min:130px; --bottom-max:18vh; --editor-min:170px; }
    }
    @media (max-height: 720px){
      :root{ --bottom-min:120px; --bottom-max:16vh; --editor-min:160px; }
      .statementbar{ padding:8px 10px; }
      .statementbox{ padding:12px 12px; }
      .statementtitle{ font-size:16px; margin-bottom:6px; }
      .statementtext{ font-size:14px; max-height:80px; }
      .coachbar{ padding:6px 10px; }
      .coach-next{ max-height:64px; padding:7px 9px; }
      .coach-right{ max-height:96px; padding:7px 9px; }
      .panel-head{ padding:7px 10px; }
      .stdin{ font-size:13px; }
      .out{ font-size:12.5px; }
      .btn, .btn2, .miniTag{ padding:8px 10px; font-size:12px; }
    }
    @media (max-height: 620px){
      /* Qu√° th·∫•p: cho ph√©p cu·ªôn trang thay v√¨ √©p m·ªçi th·ª© v√†o 1 m√†n. */
      body{ overflow:auto; }
      .page{ height:auto; min-height:100%; grid-template-rows:auto auto; }
      .bottom{ height:auto; }
      .code-wrap{ height:52vh; min-height:220px; }
      .panel{ min-height:220px; }
      #editor{ height:100%; }
    }
    #editor{ height:100%; border-top:1px solid var(--border); }

    /* Output panels */
    .bottom{ height:100%; min-height:0; display:grid; grid-template-columns:1fr 1fr; grid-template-rows:1fr; gap:12px; }
    @media (max-width: 920px){ .bottom{ grid-template-columns:1fr; grid-template-rows:1fr 1fr; } select{ max-width:none; } }
    .panel{ background:var(--card); border:1px solid var(--border); border-radius:14px; overflow:hidden; box-shadow:0 8px 22px rgba(16,24,40,.06); display:flex; flex-direction:column; min-height:0; }
    .panel-head{ padding:6px 10px; border-bottom:1px solid var(--border); background:#fff; }
    .panel-title{ font-weight:900; font-size:13px; margin:0; }
    /* Gi·ªØ g·ªçn ph·∫ßn m√¥ t·∫£ ƒë·ªÉ ti·∫øt ki·ªám chi·ªÅu cao (v·∫´n xem ƒë·ªß b·∫±ng hover/tooltip n·∫øu c·∫ßn) */
    .panel-sub{ margin-top:1px; font-size:11.5px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; line-height:1.25; }
    .stdin{ width:100%; flex:1 1 auto; min-height:0; border:0; outline:none; resize:none; padding:12px;
      font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace; font-size:14px; line-height:1.5; background:#fff; }
    .out{ width:100%; flex:1 1 auto; min-height:0; padding:12px; background:var(--out-bg); color:var(--out-text);
      font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace; font-size:13px; line-height:1.55; overflow:auto; white-space:pre-wrap; }
    .out .x{ color:var(--danger); font-weight:900; } .out .muted{ color:var(--out-muted); }
    .out .ok{ color:var(--ok); font-weight:900; } .out .hint{ color:#b7d7ff; font-weight:900; }

    /* ====== B√†i l·ªõn / B√†i nh·ªè picker (gi·ªØ giao di·ªán g·ªçn) ====== */
    .pickWrap{
      display:flex;
      align-items:center;
      gap:10px;
      width:100%;
      max-width:520px;
      min-width:220px;
      flex: 1 1 520px;
    }
    .pickWrap select{ max-width:none; }
    .groupPick{
      position:relative;
      width:140px;
      flex:0 0 140px;
      min-width:110px;
    }
    .selectOverlay{
      position:absolute;
      left:12px;
      right:34px; /* ch·ª´a ch·ªó m≈©i t√™n select */
      top:4px;
      bottom:4px;
      display:flex;
      align-items:center;
      pointer-events:none;
      background:#fff;
      color:#111827;
      font-weight:800;
      font-size:13px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      border-radius:10px;
    }

    #groupSelect{ width:100%; }
    .pickSmall{ display:flex; align-items:center; gap:8px; flex:1 1 auto; min-width:0; }
    #problemSelect{ flex:1 1 auto; min-width:0; }
    .miniTag{
      border:1px solid var(--border);
      background:#fff;
      color:#344054;
      padding:9px 10px;
      border-radius:10px;
      cursor:pointer;
      font-weight:900;
      font-size:13px;
      white-space:nowrap;
      flex:0 0 auto;
    }
    .miniTag:hover{ background:#f8fafc; }
    @media (max-width: 920px){
      .pickWrap{ max-width:none; flex-wrap:nowrap; }
      #groupSelect{ width:180px; flex:0 0 180px; }
    }

  

    /* ===== Pretest gate button ===== */
    .pretestBtn{
      border:1px dashed rgba(245,158,11,.55);
      background: rgba(245,158,11,.10);
      color:#92400e;
      padding:8px 10px;
      border-radius:999px;
      cursor:pointer;
      font-weight:900;
      font-size:12px;
      line-height:1;
      white-space:nowrap;
    }
    .pretestBtn:hover{ filter:brightness(.98); }

    /* ===== Pretest modal ===== */
    .pretestModal{ position:fixed; inset:0; z-index:9999; display:none; }
    .pretestBackdrop{ position:absolute; inset:0; background:rgba(0,0,0,.35); }
    .pretestCard{
      position:relative;
      width:calc(100% - 24px);
      max-width:1150px;
      height:calc(100vh - 80px);
      margin:40px auto 0;
      background:#fff;
      border-radius:16px;
      box-shadow:0 20px 60px rgba(0,0,0,.25);
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }
    .pretestHead{ display:flex; align-items:center; justify-content:space-between; gap:12px; padding:10px 12px; border-bottom:1px solid var(--border); background:#fff; }
    .pretestTitle{ font-size:13px; font-weight:900; color:var(--text); }
    .pretestSub{ margin-top:2px; font-size:12px; color:var(--muted); }
    .pretestX{ border:0; background:transparent; cursor:pointer; width:32px; height:32px; border-radius:10px; font-size:18px; color:var(--muted); }
    .pretestX:hover{ background:#f1f5f9; color:var(--text); }
    .pretestFrame{ flex:1; width:100%; border:0; display:block; }
    @media (max-width: 920px){ .pretestCard{ height:calc(100vh - 60px); margin:20px auto 0; } }

</style>
</head>

<body>
<div class="page">

  <div class="editor-card">
    <div class="editor-toolbar">
      <div class="toolbar-left">
        <div class="dot"></div>
        <div style="min-width:0">
          <div class="title">Python</div>
          <div class="sub" id="subtitle">Vi·∫øt code ·ªü ƒë√¢y ‚Ä¢ Realtime Coach ‚Ä¢ Test PASS/FAIL</div>
        </div>
      </div>

      <div class="toolbar-mid">
        <div class="pickWrap" id="pickWrap">
          <div class="groupPick" title="Ch·ªçn m·ª•c">
            <select id="groupSelect" aria-label="M·ª•c"></select>
            <div class="selectOverlay" id="groupOverlay" aria-hidden="true"></div>
          </div>
          <div class="pickSmall">
            <!-- Ch·ªâ gi·ªØ l·∫°i dropdown ch·ªçn b√†i nh·ªè (n√∫t "B√†i:" tr∆∞·ªõc ƒë√¢y kh√¥ng x·ªï xu·ªëng -> g√¢y hi·ªÉu nh·∫ßm) -->
            <select id="problemSelect" aria-label="B√†i nh·ªè"></select>
          </div>
        </div>

        <span class="pill" id="pill">Ch∆∞a ch·∫°y</span>
        <span class="status" id="scoreMeta">Test: 0/0</span>
      </div>

      <div class="toolbar-right">
        <div class="status" id="status">ƒêang t·∫£i Python...</div>
                <button class="btn2" id="loadBtn" disabled>N·∫°p khung</button>
        <button class="btn2" id="hintBtn" disabled>G·ª£i √Ω</button>
        <button class="btn2" id="runOnlyBtn" disabled>Ch·∫°y th·ª≠</button>
        <button class="btn2" id="practiceBtn" title="√în luy·ªán t·ªïng h·ª£p (15 tr·∫Øc nghi·ªám + 5 ƒë√∫ng/sai)">√în luy·ªán t·ªïng h·ª£p</button>
        <button class="btn" id="runBtn" disabled>Test</button>
        <button class="btn2" id="nextBtn" style="display:none;" title="Ch·ªâ hi·ªán khi b·∫°n PASS">B√†i ti·∫øp theo</button>
      </div>
    </div>


    <div class="pretestRow" id="pretestRow">
      <button class="pretestBtn" id="pretestBtn" style="display:none;" title="B·∫Øt bu·ªôc: l√†m √¥n luy·ªán tr∆∞·ªõc khi code">√în luy·ªán b·∫Øt bu·ªôc ‚Ä¢ 0/0</button>
    </div>

    <div class="statementbar">
      <div class="statementbox">
        <div class="statementtitle" id="statementTitle">ƒê·ªÅ b√†i</div>
        <pre class="statementtext" id="statementText">(ƒêang t·∫£i ƒë·ªÅ...)</pre>
      </div>
    </div>

    <div class="coachbar">
      <div class="coach-left">
        <div class="coach-title">üß† Realtime Coach (g·ª£i √Ω theo d√≤ng ƒëang g√µ)</div>
        <div class="coach-next" id="coachNext">(B·∫Øt ƒë·∫ßu g√µ code ƒë·ªÉ nh·∫≠n g·ª£i √Ω t·ª©c th√¨)</div>
      </div>
      <div class="coach-right">
        <div class="coach-title" style="margin-bottom:6px;">Checklist</div>
        <ul class="checklist" id="coachChecklist"></ul>
      </div>
    </div>

    <div class="code-wrap">
      <div id="editor"></div>
    </div>
  </div>

  <div class="bottom">
    <div class="panel">
      <div class="panel-head">
        <p class="panel-title">Input (stdin)</p>
        <div class="panel-sub" title="Nh·∫≠p d·ªØ li·ªáu ƒë·∫ßu v√†o ƒë·ªÉ ch·∫°y th·ª≠. (Test d√πng test case ri√™ng)">Nh·∫≠p d·ªØ li·ªáu ƒë·∫ßu v√†o ƒë·ªÉ ch·∫°y th·ª≠. (Test d√πng test case ri√™ng)</div>
      </div>
      <textarea class="stdin" id="stdin" spellcheck="false"></textarea>
    </div>

    <div class="panel">
      <div class="panel-head">
        <p class="panel-title">Output / L·ªói / PASS-FAIL</p>
        <div class="panel-sub" title="L·ªói ti·∫øng Vi·ªát + nguy√™n nh√¢n + c√°ch s·ª≠a theo ‚Äúƒë√∫ng b·ªánh‚Äù.">L·ªói ti·∫øng Vi·ªát + nguy√™n nh√¢n + c√°ch s·ª≠a theo ‚Äúƒë√∫ng b·ªánh‚Äù.</div>
      </div>
      <div class="out" id="out"><span class="muted">Ch∆∞a ch·∫°y.</span></div>
    </div>
  </div>

</div>


<!-- ===== PRETEST MODAL (√¥n luy·ªán b·∫Øt bu·ªôc) ===== -->
<div id="pretestModal" class="pretestModal" aria-hidden="true">
  <div class="pretestBackdrop" id="pretestBackdrop"></div>
  <div class="pretestCard" role="dialog" aria-modal="true" aria-label="B√†i t·∫≠p √¥n luy·ªán">
    <div class="pretestHead">
      <div>
        <div class="pretestTitle" id="pretestTitle">B√†i t·∫≠p √¥n luy·ªán</div>
        <div class="pretestSub" id="pretestSub">L√†m xong v√† ƒë·∫°t y√™u c·∫ßu th√¨ h·ªá th·ªëng s·∫Ω m·ªü kh√≥a ph·∫ßn code.</div>
      </div>
      <button class="pretestX" id="pretestClose" title="ƒê√≥ng">√ó</button>
    </div>
    <iframe class="pretestFrame" id="pretestFrame" src="about:blank"></iframe>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
<script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/loader.js"></script>


<!-- Firebase (optional sync) -->
<!-- Firebase Sync (Firestore) - ES Module -->
<script type="module" src="./firebase_sync_module.js"></script>
<script>
  // Session-aware keys (ƒë·ªìng b·ªô theo h·ªçc sinh/gi√°o vi√™n ƒëang ƒëƒÉng nh·∫≠p ·ªü trang cha)
  const SESSION_KEY = "py10:session";
  function getSession(){
    try{ return JSON.parse(localStorage.getItem(SESSION_KEY) || "null"); }catch(_){ return null; }
  }
  const _sess = getSession();
  const _scope = _sess && _sess.id ? String(_sess.id).trim() : "guest";
  // =======================
  // PROBLEMS (21 b√†i c√≥ s·∫µn) + B√ÄI GI√ÅO VI√äN GIAO (t·ª± ch√®n sau B√†i 21)
  // - B√†i GV giao l·∫•y t·ª´: py10:assignments (GV giao) + py10:teacherBank (ƒë·ªÅ ri√™ng GV t·∫°o)
  // - C∆° ch·∫ø kh√≥a theo th·ª© t·ª±: ch·ªâ m·ªü ƒë∆∞·ª£c b√†i sau khi PASS b√†i tr∆∞·ªõc.
  // =======================

  const NOW_YEAR = new Date().getFullYear();

  // =======================
  // Starter/"khung": KHUNG theo T·ª™NG B√ÄI (kh√¥ng ƒë∆∞a code m·∫´u)
  // - M·ª•c ti√™u: HS b·∫•m "N·∫°p khung" ch·ªâ nh·∫≠n ƒë∆∞·ª£c d√†n √Ω ƒë√∫ng b√†i ƒëang l√†m.
  // - Khi chuy·ªÉn b√†i: editor KH√îNG t·ª± hi·ªán khung; m·∫∑c ƒë·ªãnh ƒë·ªÉ tr·ªëng (ho·∫∑c t·∫£i code ƒë√£ l∆∞u).
  //   HS mu·ªën xem khung th√¨ b·∫•m "N·∫°p khung".
  // - Kh√¥ng ch√®n s·∫µn input()/print()/range()... ƒë·ªÉ tr√°nh "ƒë∆∞a ra code".
  // =======================

  // Khung b√°m s√°t 21 b√†i c√≥ s·∫µn.
  // V·ªõi b√†i GV giao (kh√¥ng c√≥ trong map), h·ªá th·ªëng t·ª± t·∫°o khung d·ª±a tr√™n ƒë·ªÅ b√†i.
  const SCAFFOLD_BY_ID = {
    b01:{ input:"Kh√¥ng c√≥.", process:"Chu·∫©n b·ªã chu·ªói ƒë√∫ng theo ƒë·ªÅ.", output:"In ƒë√∫ng: Hello, world!" },
    b02:{ input:"1 s·ªë nguy√™n n.", process:"Gi·ªØ nguy√™n gi√° tr·ªã n.", output:"In ra n." },
    b03:{ input:"T√™n v√† nƒÉm sinh.", process:"Tu·ªïi = nƒÉm hi·ªán t·∫°i ‚àí nƒÉm sinh.", output:"In t√™n v√† tu·ªïi (ƒë√∫ng ƒë·ªãnh d·∫°ng)." },
    b04:{ input:"a, b (cm), a>b>0.", process:"T√≠nh P=2(a+b) v√† S=a√ób.", output:"In P v√† S." },
    b05:{ input:"3 s·ªë a, b, c.", process:"TBC=(a+b+c)/3, l√†m tr√≤n 2 ch·ªØ s·ªë.", output:"In TBC ƒë√£ l√†m tr√≤n." },
    b06:{ input:"S·ªë nguy√™n n.", process:"Ki·ªÉm tra n chia h·∫øt cho 2.", output:"In k·∫øt lu·∫≠n ch·∫µn/l·∫ª." },
    b07:{ input:"S·ªë nguy√™n n.", process:"So s√°nh n v·ªõi 0.", output:"In k·∫øt lu·∫≠n √¢m/d∆∞∆°ng." },
    b08:{ input:"S·ªë nguy√™n n.", process:"Ki·ªÉm tra n chia h·∫øt cho 3 v√† 5.", output:"In k·∫øt lu·∫≠n theo ƒë·ªÅ." },
    b09:{ input:"a, b, c (nguy√™n d∆∞∆°ng).", process:"Ki·ªÉm tra ƒëi·ªÅu ki·ªán tam gi√°c a+b>c, a+c>b, b+c>a.", output:"In c√≥/kh√¥ng l√† tam gi√°c." },
    b10:{ input:"S·ªë ƒëi·ªán ti√™u th·ª• (kWh).", process:"T√≠nh ti·ªÅn theo 3 m·ª©c (‚â§50, 51‚Äì100, >100) ƒë√∫ng ƒë·ªÅ.", output:"In s·ªë ti·ªÅn ƒëi·ªán." },
    b11:{ input:"Kh√¥ng c√≥.", process:"L·∫∑p ƒë√∫ng 10 l·∫ßn.", output:"M·ªói d√≤ng in 1 t·ª´ hello." },
    b12:{ input:"Kh√¥ng c√≥.", process:"Duy·ªát d√£y 1..100.", output:"In c√°c s·ªë 1..100." },
    b13:{ input:"Kh√¥ng c√≥.", process:"Duy·ªát c√°c s·ªë ch·∫µn < 100.", output:"In c√°c s·ªë ch·∫µn." },
    b14:{ input:"2 s·ªë nguy√™n a, b (a<b).", process:"Duy·ªát [a,b], l·∫•y s·ªë chia h·∫øt cho 3 v√† 5.", output:"In c√°c s·ªë th·ªèa ƒëi·ªÅu ki·ªán." },
    b15:{ input:"S·ªë nguy√™n d∆∞∆°ng n.", process:"Li·ªát k√™ c√°c ∆∞·ªõc c·ªßa n (tƒÉng d·∫ßn) v√† ƒë·∫øm s·ªë ∆∞·ªõc.", output:"In c√°c ∆∞·ªõc v√† s·ªë l∆∞·ª£ng ∆∞·ªõc." },
    b16:{ input:"S·ªë t·ª± nhi√™n n.", process:"N·∫øu n<2: kh√¥ng; else ki·ªÉm tra 2..‚àön.", output:"In k·∫øt lu·∫≠n nguy√™n t·ªë/kh√¥ng." },
    b17:{ input:"Kh√¥ng c√≥.", process:"T√≠nh s=1+2+... ƒë·∫øn khi s>100.", output:"In gi√° tr·ªã s." },
    b18:{ input:"Kh√¥ng c√≥.", process:"D√£y 1,4,7,...; t√¨m s·ªë h·∫°ng l·ªõn nh·∫•t ‚â§100.", output:"In s·ªë h·∫°ng ƒë√≥." },
    b19:{ input:"Kh√¥ng c√≥.", process:"Trong 0..99: t√≠nh t·ªïng s·ªë ch·∫µn v√† ƒë·∫øm s·ªë l∆∞·ª£ng.", output:"In t·ªïng r·ªìi s·ªë l∆∞·ª£ng." },
    b20:{ input:"S·ªë nguy√™n d∆∞∆°ng n.", process:"ƒê·∫øm s·ªë ch·ªØ s·ªë c·ªßa n.", output:"In s·ªë ch·ªØ s·ªë." },
    b21:{ input:"S·ªë nguy√™n d∆∞∆°ng n.", process:"ƒê·∫£o th·ª© t·ª± ch·ªØ s·ªë c·ªßa n.", output:"In s·ªë ƒë·∫£o." },
  };

  function _cleanLine(s){
    return String(s||"").replace(/\s+/g, " ").trim();
  }
  function _shorten(s, maxLen){
    const t = _cleanLine(s);
    if(!t) return "";
    if(t.length <= maxLen) return t;
    return t.slice(0, Math.max(0, maxLen-1)).trimEnd() + "‚Ä¶";
  }

  function autoScaffoldFromStatement(statement, req){
    const s = String(statement||"").replace(/\r/g, "");
    const parts = s.split("\n").map(x=>x.trim()).filter(Boolean);

    const _stripLead = (t, kind)=>{
      let x = _cleanLine(t);
      if(!x) return "";
      if(kind === "input"){
        x = x.replace(/^(nh·∫≠p(\s+v√†o)?|ƒë·ªçc|cho)\s*[:\-‚Äì]?\s*/i, "").trim();
      } else if(kind === "output"){
        x = x.replace(/^(in\s*ra|hi·ªÉn\s*th·ªã|ƒë∆∞a\s*ra|xu·∫•t)\s*[:\-‚Äì]?\s*/i, "").trim();
      }
      return x;
    };

    const inputLines  = parts.filter(l => /\b(nh·∫≠p|ƒë·ªçc)\b/i.test(l));
    const outputLines = parts.filter(l => /\b(in\s*ra|hi·ªÉn\s*th·ªã|ƒë∆∞a\s*ra|xu·∫•t)\b/i.test(l));
    const otherLines  = parts.filter(l => !inputLines.includes(l) && !outputLines.includes(l));

    let input = inputLines.length ? _shorten(_stripLead(inputLines.join(" "), "input"), 80) : "Kh√¥ng r√µ d·ªØ li·ªáu v√†o (ƒë·ªçc ƒë√∫ng theo ƒë·ªÅ).";
    if(req && Object.prototype.hasOwnProperty.call(req, "input") && !req.input) input = "Kh√¥ng c√≥.";

    let output = outputLines.length ? _shorten(_stripLead(outputLines.join(" "), "output"), 90) : "In k·∫øt qu·∫£ theo ƒë·ªÅ (ƒë√∫ng ƒë·ªãnh d·∫°ng).";

    let process = otherLines.length ? _shorten(otherLines.join(" "), 105) : "Gi·∫£i theo y√™u c·∫ßu c·ªßa ƒë·ªÅ.";
    if(req && req.math && process === "Gi·∫£i theo y√™u c·∫ßu c·ªßa ƒë·ªÅ.") process = "T√≠nh to√°n theo c√¥ng th·ª©c c·ªßa ƒë·ªÅ.";
    if(req && req.if && !/tr∆∞·ªùng h·ª£p|ƒëi·ªÅu ki·ªán|so s√°nh|chia h·∫øt/i.test(process)) process = _shorten("X√©t ƒëi·ªÅu ki·ªán / chia tr∆∞·ªùng h·ª£p theo ƒë·ªÅ.", 105);
    if(req && req.loop && !/l·∫∑p|duy·ªát|d√£y/i.test(process)) process = _shorten("L·∫∑p/duy·ªát theo y√™u c·∫ßu c·ªßa ƒë·ªÅ.", 105);

    return { input, process, output };
  }


  function makeNoCodeStarter(problem){
    const req = (problem && typeof problem.req === "object" && problem.req) ? problem.req : {};
    const id = String(problem?.id || "").trim();

    const custom = SCAFFOLD_BY_ID[id] || null;
    const auto = custom ? null : autoScaffoldFromStatement(problem?.statement, req);

    const input  = _shorten(custom ? custom.input  : auto.input,  90);
    const process= _shorten(custom ? custom.process: auto.process, 110);
    const output = _shorten(custom ? custom.output : auto.output,  100);

    // N·∫†P KHUNG: 3 d√≤ng, ng·∫Øn g·ªçn, b√°m s√°t ƒë·ªÅ (kh√¥ng c√≥ code m·∫´u)
    const lines = [];
    lines.push(`# Nh·∫≠p: ${input}`);
    lines.push(`# X·ª≠ l√Ω: ${process}`);
    lines.push(`# In: ${output}`);
    lines.push(``);
    return lines.join("\n");
  }


  function applyNoCodeStarterToList(list){
    try{
      for(const p of (list || [])){
        // Lu√¥n ghi ƒë√® starter ƒë·ªÉ ƒë·∫£m b·∫£o "khung" kh√¥ng bao gi·ªù l√† code m·∫´u.
        p.starter = makeNoCodeStarter(p);
      }
    }catch(e){}
  }

  // 21 b√†i c√≥ s·∫µn (c·ªë ƒë·ªãnh)
  const BASE_PROBLEMS = [
    // ====== C√ÇU L·ªÜNH V√ÄO/RA ƒê∆†N GI·∫¢N (5 b√†i) ======
    {
      id:"b01",
      group:"io",
      title:"B√†i 1: Hello, world!",
      statement:`Vi·∫øt ch∆∞∆°ng tr√¨nh in ra "Hello, world!".`,
      starter:`# TODO: In ra "Hello, world!"\n`,
      sampleInput:"",
      hints:{
        level1:["B√†i n√†y ch·ªâ c·∫ßn 1 c√¢u l·ªánh in ra m√†n h√¨nh."],
        level2:["D√πng h√†m print(...) ƒë·ªÉ in chu·ªói."],
        level3:["V√≠ d·ª•: print(\"Hello\")"],
        level4:["Nh·ªõ ƒë√∫ng ch√≠nh t·∫£: Hello, world! (c√≥ d·∫•u ph·∫©y v√† d·∫•u !)."],
        level5:["N·∫øu b·ªã FAIL: ki·ªÉm tra b·∫°n c√≥ in ra ƒë√∫ng ch·ªØ 'Hello, world!' hay kh√¥ng."]
      },
      tests:{
        public:[{input:"",expected:"hello, world!"}],
        hidden:[{input:"",expected:"hello, world!"}]
      },
      checker:(out,expected)=>{
        const o=simplifyText(out);
        return o.includes("hello") && o.includes("world");
      },
      req:{ input:false, print:true }
    },
    {
      id:"b02",
      group:"io",
      title:"B√†i 2: Nh·∫≠p m·ªôt s·ªë nguy√™n v√† in ra",
      statement:"Nh·∫≠p v√†o m·ªôt s·ªë NGUY√äN t·ª´ b√†n ph√≠m v√† in ra s·ªë v·ª´a nh·∫≠p.",
      starter:`x = int(input("Nh·∫≠p s·ªë nguy√™n: "))\n\n# TODO: In ra l·∫°i s·ªë v·ª´a nh·∫≠p\n`,
      sampleInput:"7",
      hints:{
        level1:["B·∫°n c·∫ßn ƒë·ªçc 1 gi√° tr·ªã v√† in l·∫°i ƒë√∫ng gi√° tr·ªã ƒë√≥."],
        level2:["D√πng input() ƒë·ªÉ nh·∫≠p v√† print() ƒë·ªÉ in."],
        level3:["D√πng int(input(...)) ƒë·ªÉ nh·∫≠p s·ªë nguy√™n r·ªìi print(x)."],
        level4:["Nh·ªõ d√πng int(...) ƒë·ªÉ nh·∫≠p ƒë√∫ng ki·ªÉu s·ªë nguy√™n."],
        level5:["N·∫øu b·ªã l·ªói: ki·ªÉm tra b·∫°n c√≥ nh·∫≠p ƒë·ªß 1 d√≤ng d·ªØ li·ªáu kh√¥ng."]
      },
      tests:{
        public:[{input:"7\n",expected:7},{input:"-12\n",expected:-12}],
        hidden:[{input:"35\n",expected:35},{input:"0\n",expected:0}]
      },
      checker:(out,expected)=>{
        const got = extractFirstNumber(out);
        if(got===null) return false;
        return Math.abs(got-Number(expected)) < 0.0001;
      },
      req:{ input:true, print:true }
    },
    {
      id:"b03",
      group:"io",
      title:"B√†i 3: T√™n v√† tu·ªïi hi·ªán t·∫°i",
      statement:`Nh·∫≠p v√†o t√™n v√† nƒÉm sinh c·ªßa em.\nIn ra m√†n h√¨nh t√™n v√† s·ªë tu·ªïi hi·ªán t·∫°i c·ªßa em.\n\nG·ª£i √Ω: tu·ªïi = nƒÉm hi·ªán t·∫°i - nƒÉm sinh.`,
      starter:`name = input("Nh·∫≠p t√™n: ")\ny = int(input("Nh·∫≠p nƒÉm sinh: "))\n\n# TODO: T√≠nh tu·ªïi hi·ªán t·∫°i v√† in ra t√™n + tu·ªïi\n`,
      sampleInput:`An\n2010`,
      hints:{
        level1:["B·∫°n c·∫ßn t√≠nh tu·ªïi d·ª±a tr√™n nƒÉm sinh."],
        level2:["Tu·ªïi = nƒÉm hi·ªán t·∫°i - nƒÉm sinh."],
        level3:["B·∫°n c√≥ th·ªÉ l·∫•y nƒÉm hi·ªán t·∫°i b·∫±ng datetime ho·∫∑c d√πng c√¥ng th·ª©c v·ªõi nƒÉm hi·ªán t·∫°i b·∫°n bi·∫øt."],
        level4:["In ra c·∫£ t√™n v√† tu·ªïi (c√≥ th·ªÉ c√πng d√≤ng ho·∫∑c kh√°c d√≤ng)."],
        level5:["N·∫øu FAIL: ki·ªÉm tra b·∫°n c√≥ in ƒë√∫ng tu·ªïi theo c√¥ng th·ª©c kh√¥ng."]
      },
      tests:{
        public:[
          {input:"An\n2010\n",expected:{name:"An",birthYear:2010}},
          {input:"Minh\n2005\n",expected:{name:"Minh",birthYear:2005}}
        ],
        hidden:[
          {input:"Lan\n2012\n",expected:{name:"Lan",birthYear:2012}},
          {input:"Nam\n1999\n",expected:{name:"Nam",birthYear:1999}}
        ]
      },
      checker:(out,expected)=>{
        const o = simplifyText(out);
        const nameParts = simplifyText(expected.name).split(/\s+/).filter(Boolean);
        const okName = nameParts.every(p=>o.includes(p));
        const age = NOW_YEAR - Number(expected.birthYear);
        const nums = (String(out??"").match(/-?\d+/g) || []).map(n=>Number(n));
        const okAge = nums.includes(age);
        return okName && okAge;
      },
      req:{ input:true, print:true, math:true }
    },
    {
      id:"b04",
      group:"io",
      title:"B√†i 4: H√¨nh ch·ªØ nh·∫≠t (chu vi, di·ªán t√≠ch)",
      statement:`Nh·∫≠p v√†o chi·ªÅu d√†i a (cm), chi·ªÅu r·ªông b (cm) c·ªßa h√¨nh ch·ªØ nh·∫≠t (a>b>0).\nT√≠nh v√† in ra chu vi v√† di·ªán t√≠ch c·ªßa h√¨nh ch·ªØ nh·∫≠t ƒë√≥.`,
      starter:`a = float(input("Nh·∫≠p a (cm): "))\nb = float(input("Nh·∫≠p b (cm): "))\n\n# TODO: T√≠nh chu vi P v√† di·ªán t√≠ch S\n# P = 2*(a+b)\n# S = a*b\n`,
      sampleInput:`10\n5`,
      hints:{
        level1:["B·∫°n c·∫ßn t√≠nh 2 gi√° tr·ªã: chu vi v√† di·ªán t√≠ch."],
        level2:["Chu vi P = 2*(a+b). Di·ªán t√≠ch S = a*b."],
        level3:["Nh·∫≠p a,b ‚Üí t√≠nh P,S ‚Üí in ra."],
        level4:["C√≥ th·ªÉ in theo d·∫°ng: P v√† S (c√πng d√≤ng ho·∫∑c kh√°c d√≤ng)."],
        level5:["N·∫øu FAIL: ki·ªÉm tra c√¥ng th·ª©c v√† b·∫°n c√≥ in ƒë·ªß 2 s·ªë kh√¥ng."]
      },
      tests:{
        public:[
          {input:"10\n5\n",expected:{p:30,s:50}},
          {input:"8\n3\n",expected:{p:22,s:24}}
        ],
        hidden:[
          {input:"2.5\n1.5\n",expected:{p:8.0,s:3.75}},
          {input:"100\n1\n",expected:{p:202,s:100}}
        ]
      },
      checker:(out,expected)=>{
        const nums = (String(out??"").match(/-?\d+(\.\d+)?/g) || []).map(x=>Number(x));
        if(!nums.length) return false;
        const okP = nums.some(v=>Math.abs(v-Number(expected.p))<0.01);
        const okS = nums.some(v=>Math.abs(v-Number(expected.s))<0.01);
        return okP && okS;
      },
      req:{ input:true, print:true, math:true }
    },
    {
      id:"b05",
      group:"io",
      title:"B√†i 5: Trung b√¨nh c·ªông 3 s·ªë (l√†m tr√≤n 2 ch·ªØ s·ªë)",
      statement:"Nh·∫≠p 3 s·ªë a, b, c. T√≠nh trung b√¨nh c·ªông v√† in ra k·∫øt qu·∫£ l√†m tr√≤n ƒë·∫øn 2 ch·ªØ s·ªë th·∫≠p ph√¢n.",
      starter:`a = float(input("Nh·∫≠p a: "))\nb = float(input("Nh·∫≠p b: "))\nc = float(input("Nh·∫≠p c: "))\n\n# TODO: T√≠nh trung b√¨nh c·ªông v√† in ra (l√†m tr√≤n 2 ch·ªØ s·ªë th·∫≠p ph√¢n)\n`,
      sampleInput:`1\n2\n2`,
      hints:{
        level1:["Trung b√¨nh c·ªông = (a+b+c)/3."],
        level2:["Sau khi t√≠nh, l√†m tr√≤n ƒë·∫øn 2 ch·ªØ s·ªë th·∫≠p ph√¢n."],
        level3:["B·∫°n c√≥ th·ªÉ d√πng round(x, 2)."],
        level4:["Ho·∫∑c d√πng ƒë·ªãnh d·∫°ng: print(f\"{avg:.2f}\")"],
        level5:["N·∫øu FAIL: ki·ªÉm tra ƒë√∫ng c√¥ng th·ª©c v√† ƒë√∫ng l√†m tr√≤n 2 ch·ªØ s·ªë."]
      },
      tests:{
        public:[
          {input:"1\n2\n2\n",expected:1.67},
          {input:"10\n20\n30\n",expected:20.00}
        ],
        hidden:[
          {input:"0\n0\n0\n",expected:0.00},
          {input:"-1\n0\n1\n",expected:0.00}
        ]
      },
      checker:(out,expected)=>{
        const got = extractFirstNumber(out);
        if(got===null) return false;
        return Math.abs(got-Number(expected)) < 0.0005;
      },
      req:{ input:true, print:true, math:true }
    },

    // ====== C√ÇU L·ªÜNH if (5 b√†i) ======
    {
      id:"b06",
      group:"if",
      title:"B√†i 6: Ki·ªÉm tra ch·∫µn hay l·∫ª",
      statement:"Nh·∫≠p m·ªôt s·ªë nguy√™n n, in ra th√¥ng b√°o n l√† s·ªë ch·∫µn hay s·ªë l·∫ª.",
      starter:`n = int(input("Nh·∫≠p n: "))\n\n# TODO: In ra th√¥ng b√°o n l√† s·ªë ch·∫µn hay s·ªë l·∫ª\n`,
      sampleInput:"7",
      hints:{
        level1:["C√≥ 2 tr∆∞·ªùng h·ª£p: ch·∫µn ho·∫∑c l·∫ª."],
        level2:["Ki·ªÉm tra n % 2 == 0."],
        level3:["D√πng if/else."],
        level4:["N·∫øu n%2==0 ‚Üí ch·∫µn, ng∆∞·ª£c l·∫°i ‚Üí l·∫ª."],
        level5:["N·∫øu FAIL: ki·ªÉm tra ch·ªØ b·∫°n in ra c√≥ ch·ª©a 'ch·∫µn' ho·∫∑c 'l·∫ª'."]
      },
      tests:{
        public:[{input:"2\n",expected:"chan"},{input:"7\n",expected:"le"}],
        hidden:[{input:"0\n",expected:"chan"},{input:"-3\n",expected:"le"}]
      },
      checker:(out,expected)=>{
        const o=simplifyText(out);
        if(expected==="chan") return o.includes("chan") || o.includes("so chan") || o.includes("ch·∫µn");
        if(expected==="le") return o.includes("le") || o.includes("so le") || o.includes("l·∫ª");
        return false;
      },
      req:{ input:true, print:true, if:true }
    },
    {
      id:"b07",
      group:"if",
      title:"B√†i 7: Ki·ªÉm tra s·ªë √¢m hay d∆∞∆°ng",
      statement:"Nh·∫≠p m·ªôt s·ªë nguy√™n n, in ra th√¥ng b√°o n l√† s·ªë √¢m hay s·ªë d∆∞∆°ng.",
      starter:`n = int(input("Nh·∫≠p n: "))\n\n# TODO: In ra n l√† s·ªë √¢m hay s·ªë d∆∞∆°ng\n`,
      sampleInput:"-5",
      hints:{
        level1:["C√≥ 2 tr∆∞·ªùng h·ª£p: √¢m ho·∫∑c d∆∞∆°ng."],
        level2:["So s√°nh n v·ªõi 0."],
        level3:["D√πng if/else."],
        level4:["N·∫øu n < 0 ‚Üí √¢m, ng∆∞·ª£c l·∫°i ‚Üí d∆∞∆°ng."],
        level5:["N·∫øu FAIL: ki·ªÉm tra b·∫°n c√≥ in ƒë√∫ng ch·ªØ '√¢m'/'d∆∞∆°ng' kh√¥ng."]
      },
      tests:{
        public:[{input:"-5\n",expected:"am"},{input:"7\n",expected:"duong"}],
        hidden:[{input:"-1\n",expected:"am"},{input:"100\n",expected:"duong"}]
      },
      checker:(out,expected)=>{
        const o=simplifyText(out);
        if(expected==="am") return o.includes("am") && !o.includes("khong am");
        if(expected==="duong") return o.includes("duong") || o.includes("duong tinh");
        return false;
      },
      req:{ input:true, print:true, if:true }
    },
    {
      id:"b08",
      group:"if",
      title:"B√†i 8: Chia h·∫øt cho 3 v√† 5",
      statement:"Nh·∫≠p m·ªôt s·ªë nguy√™n n. Ki·ªÉm tra n c√≥ chia h·∫øt cho c·∫£ 3 v√† 5 kh√¥ng, r·ªìi in ra k·∫øt lu·∫≠n.",
      starter:`n = int(input("Nh·∫≠p n: "))\n\n# TODO: Ki·ªÉm tra chia h·∫øt cho c·∫£ 3 v√† 5\n`,
      sampleInput:"15",
      hints:{
        level1:["B·∫°n c·∫ßn ki·ªÉm tra ƒë·ªìng th·ªùi 2 ƒëi·ªÅu ki·ªán."],
        level2:["ƒêi·ªÅu ki·ªán: n % 3 == 0 v√† n % 5 == 0."],
        level3:["D√πng if/else, c√≥ th·ªÉ d√πng and."],
        level4:["N·∫øu ƒë√∫ng ‚Üí in 'chia h·∫øt', n·∫øu sai ‚Üí in 'kh√¥ng chia h·∫øt'."],
        level5:["N·∫øu FAIL: ki·ªÉm tra b·∫°n c√≥ d√πng and v√† % ƒë√∫ng kh√¥ng."]
      },
      tests:{
        public:[{input:"15\n",expected:true},{input:"14\n",expected:false}],
        hidden:[{input:"30\n",expected:true},{input:"25\n",expected:false}]
      },
      checker:(out,expected)=>{
        const o=simplifyText(out);
        const hasYes = o.includes("chia het") || o.includes("chiahhet") || o.includes("yes") || o.trim()==="true";
        const hasNo  = o.includes("khong") || o.includes("no") || o.trim()==="false";
        return expected ? (hasYes && !hasNo) : hasNo;
      },
      req:{ input:true, print:true, if:true }
    },
    {
      id:"b09",
      group:"if",
      title:"B√†i 9: Ki·ªÉm tra tam gi√°c",
      statement:"Nh·∫≠p 3 s·ªë nguy√™n d∆∞∆°ng a, b, c. Ki·ªÉm tra a, b, c c√≥ th·ªÉ l√† ƒë·ªô d√†i 3 c·∫°nh c·ªßa tam gi√°c kh√¥ng.",
      starter:`a = int(input("Nh·∫≠p a: "))\nb = int(input("Nh·∫≠p b: "))\nc = int(input("Nh·∫≠p c: "))\n\n# TODO: Ki·ªÉm tra ƒëi·ªÅu ki·ªán tam gi√°c v√† in k·∫øt lu·∫≠n\n`,
      sampleInput:`3\n4\n5`,
      hints:{
        level1:["Tam gi√°c c·∫ßn th·ªèa 3 b·∫•t ƒë·∫≥ng th·ª©c."],
        level2:["ƒêi·ªÅu ki·ªán: a+b>c, a+c>b, b+c>a."],
        level3:["D√πng if/else v·ªõi ƒëi·ªÅu ki·ªán k·∫øt h·ª£p and."],
        level4:["N·∫øu ƒë√∫ng ‚Üí in 'l√† tam gi√°c', ng∆∞·ª£c l·∫°i ‚Üí 'kh√¥ng ph·∫£i tam gi√°c'."],
        level5:["N·∫øu FAIL: ki·ªÉm tra d√πng '>' (kh√¥ng ph·∫£i >=)."]
      },
      tests:{
        public:[{input:"3\n4\n5\n",expected:true},{input:"1\n2\n3\n",expected:false}],
        hidden:[{input:"5\n5\n9\n",expected:true},{input:"2\n2\n5\n",expected:false}]
      },
      checker:(out,expected)=>{
        const o=simplifyText(out);
        const yes = (o.includes("tam giac") && !o.includes("khong")) || o.includes("yes") || o.trim()==="true";
        const no  = o.includes("khong") || o.includes("no") || o.trim()==="false";
        return expected ? yes : no;
      },
      req:{ input:true, print:true, if:true }
    },
    {
      id:"b10",
      group:"if",
      title:"B√†i 10: T√≠nh ti·ªÅn ƒëi·ªán (kh√¥ng l≈©y ti·∫øn)",
      statement:`Nh·∫≠p s·ªë ƒëi·ªán ti√™u th·ª• (kWh).\nT√≠nh ti·ªÅn:\n- kWh ‚â§ 50: ti·ªÅn = kWh √ó 1678\n- 50 < kWh ‚â§ 100: ti·ªÅn = kWh √ó 1734\n- kWh > 100: ti·ªÅn = kWh √ó 2014\n(ƒê∆°n gi√° theo m·ª©c, kh√¥ng lu·ªπ ti·∫øn)`,
      starter:`kwh = float(input("Nh·∫≠p kWh: "))\n\n# TODO: T√≠nh ti·ªÅn ƒëi·ªán v√† in ra (ƒë∆°n v·ªã ƒë·ªìng)\n`,
      sampleInput:"60",
      hints:{
        level1:["Chia 3 tr∆∞·ªùng h·ª£p theo kWh."],
        level2:["D√πng if/elif/else v·ªõi c√°c m·ªëc 50 v√† 100."],
        level3:["M·ªói tr∆∞·ªùng h·ª£p nh√¢n ƒë√∫ng ƒë∆°n gi√°."],
        level4:["kwh<=50 ‚Üí*1678; kwh<=100 ‚Üí*1734; else ‚Üí*2014"],
        level5:["N·∫øu FAIL: ki·ªÉm tra ƒë√∫ng bi√™n v√† ƒë√∫ng ƒë∆°n gi√°."]
      },
      tests:{
        public:[{input:"50\n",expected:83900},{input:"60\n",expected:104040}],
        hidden:[{input:"100\n",expected:173400},{input:"120\n",expected:241680}]
      },
      checker:(out,expected)=>{
        const got=extractFirstNumber(out);
        return got!==null && Math.abs(got-expected)<0.6;
      },
      req:{ input:true, print:true, if:true, math:true }
    },

    // ====== C√ÇU L·ªÜNH for (6 b√†i) ======
    {
      id:"b11",
      group:"for",
      title:"B√†i 11: In 10 l·∫ßn t·ª´ hello",
      statement:"In ra m√†n h√¨nh 10 t·ª´ ‚Äúhello‚Äù, m·ªói t·ª´ tr√™n m·ªôt d√≤ng ri√™ng bi·ªát.",
      starter:`# TODO: In 10 l·∫ßn t·ª´ "hello", m·ªói l·∫ßn 1 d√≤ng\n`,
      sampleInput:"",
      hints:{
        level1:["B·∫°n c·∫ßn l·∫∑p 10 l·∫ßn."],
        level2:["D√πng v√≤ng l·∫∑p for v√† range(10)."],
        level3:["M·ªói v√≤ng l·∫∑p: print(\"hello\")."],
        level4:["range(10) ch·∫°y 10 l·∫ßn (0..9)."],
        level5:["N·∫øu FAIL: ki·ªÉm tra ƒë·ªß 10 d√≤ng v√† ƒë√∫ng ch·ªØ 'hello'."]
      },
      tests:{
        public:[{input:"",expected:10}],
        hidden:[{input:"",expected:10}]
      },
      checker:(out,expected)=>{
        const lines = normalizeOutput(out).trim().split(/\n+/).filter(x=>x.trim()!=="");
        if(lines.length !== Number(expected)) return false;
        return lines.every(l => simplifyText(l).trim() === "hello");
      },
      req:{ input:false, print:true, loop:true }
    },
    {
      id:"b12",
      group:"for",
      title:"B√†i 12: In c√°c s·ªë t·ª´ 1 ƒë·∫øn 100",
      statement:"In ra m√†n h√¨nh c√°c s·ªë t·ª´ 1 ƒë·∫øn 100, m·ªói s·ªë c√°ch nhau b·ªüi m·ªôt d·∫•u c√°ch (ho·∫∑c xu·ªëng d√≤ng).",
      starter:`# TODO: In c√°c s·ªë t·ª´ 1 ƒë·∫øn 100\n`,
      sampleInput:"",
      hints:{
        level1:["B·∫°n c·∫ßn in d√£y s·ªë 1..100."],
        level2:["D√πng v√≤ng l·∫∑p for i in range(1, 101)."],
        level3:["In i ra m·ªói v√≤ng l·∫∑p."],
        level4:["C√≥ th·ªÉ print(i, end=' ') ƒë·ªÉ c√πng 1 d√≤ng."],
        level5:["N·∫øu FAIL: ki·ªÉm tra ƒë·ªß 100 s·ªë v√† ƒë√∫ng th·ª© t·ª±."]
      },
      tests:{
        public:[{input:"",expectedTokens:Array.from({length:100},(_,i)=>String(i+1))}],
        hidden:[{input:"",expectedTokens:Array.from({length:100},(_,i)=>String(i+1))}]
      },
      checker:(out,expected,input,t)=>{
        const want=t.expectedTokens;
        const nums = String(out ?? "").match(/-?\d+/g) || [];
        if(nums.length!==want.length) return false;
        for(let i=0;i<want.length;i++){
          if(String(nums[i]) !== String(want[i])) return false;
        }
        return true;
      },
      req:{ input:false, print:true, loop:true }
    },
    {
      id:"b13",
      group:"for",
      title:"B√†i 13: In c√°c s·ªë ch·∫µn nh·ªè h∆°n 100",
      statement:"In ra c√°c s·ªë ch·∫µn nh·ªè h∆°n 100 (2, 4, 6, ..., 98), m·ªói s·ªë c√°ch nhau b·ªüi m·ªôt d·∫•u c√°ch (ho·∫∑c xu·ªëng d√≤ng).",
      starter:`# TODO: In c√°c s·ªë ch·∫µn nh·ªè h∆°n 100\n`,
      sampleInput:"",
      hints:{
        level1:["S·ªë ch·∫µn tƒÉng d·∫ßn c√°ch nhau 2."],
        level2:["B·∫Øt ƒë·∫ßu t·ª´ 2 ƒë·∫øn 98."],
        level3:["D√πng range(2, 100, 2)."],
        level4:["M·ªói v√≤ng l·∫∑p in i."],
        level5:["N·∫øu FAIL: ki·ªÉm tra b·∫°n c√≥ b·∫Øt ƒë·∫ßu t·ª´ 2 v√† d·ª´ng tr∆∞·ªõc 100 kh√¥ng."]
      },
      tests:{
        public:[{input:"",expectedTokens:Array.from({length:49},(_,i)=>String((i+1)*2))}],
        hidden:[{input:"",expectedTokens:Array.from({length:49},(_,i)=>String((i+1)*2))}]
      },
      checker:(out,expected,input,t)=>{
        const want=t.expectedTokens;
        const nums = String(out ?? "").match(/-?\d+/g) || [];
        if(nums.length!==want.length) return false;
        for(let i=0;i<want.length;i++){
          if(String(nums[i]) !== String(want[i])) return false;
        }
        return true;
      },
      req:{ input:false, print:true, loop:true }
    },
    {
      id:"b14",
      group:"for",
      title:"B√†i 14: Chia h·∫øt cho 3 v√† 5 trong ƒëo·∫°n [a, b]",
      statement:"Nh·∫≠p hai s·ªë nguy√™n a, b (a<b). In ra c√°c s·ªë chia h·∫øt cho c·∫£ 3 v√† 5 trong ƒëo·∫°n [a, b]. (N·∫øu kh√¥ng c√≥, kh√¥ng in g√¨.)",
      starter:`a = int(input("Nh·∫≠p a: "))\nb = int(input("Nh·∫≠p b: "))\n\n# TODO: In c√°c s·ªë chia h·∫øt cho c·∫£ 3 v√† 5 trong [a, b]\n`,
      sampleInput:`1\n40`,
      hints:{
        level1:["B·∫°n c·∫ßn duy·ªát c√°c s·ªë t·ª´ a ƒë·∫øn b."],
        level2:["ƒêi·ªÅu ki·ªán: i % 3 == 0 v√† i % 5 == 0."],
        level3:["D√πng for i in range(a, b+1)."],
        level4:["N·∫øu th·ªèa ƒëi·ªÅu ki·ªán th√¨ in i."],
        level5:["N·∫øu FAIL: ki·ªÉm tra range c√≥ b+1 v√† ƒëi·ªÅu ki·ªán chia h·∫øt."]
      },
      tests:{
        public:[
          {input:"1\n40\n",expectedTokens:["15","30"]},
          {input:"1\n14\n",expectedTokens:[]}
        ],
        hidden:[
          {input:"10\n16\n",expectedTokens:["15"]},
          {input:"100\n160\n",expectedTokens:["105","120","135","150"]}
        ]
      },
      checker:(out,expected,input,t)=>{
        const want=t.expectedTokens;
        const nums = String(out ?? "").match(/-?\d+/g) || [];
        if(nums.length!==want.length) return false;
        for(let i=0;i<want.length;i++){
          if(String(nums[i]) !== String(want[i])) return false;
        }
        return true;
      },
      req:{ input:true, print:true, loop:true, if:true }
    },
    {
      id:"b15",
      group:"for",
      title:"B√†i 15: In c√°c ∆∞·ªõc c·ªßa n v√† s·ªë l∆∞·ª£ng ∆∞·ªõc",
      statement:`Nh·∫≠p s·ªë nguy√™n d∆∞∆°ng n.\nIn ra c√°c ∆∞·ªõc c·ªßa n (tƒÉng d·∫ßn).\nSau ƒë√≥ in ra s·ªë l∆∞·ª£ng c√°c ∆∞·ªõc c·ªßa n ·ªü cu·ªëi (c√≥ th·ªÉ c√πng d√≤ng ho·∫∑c d√≤ng m·ªõi).`,
      starter:`n = int(input("Nh·∫≠p n: "))\n\n# TODO:\n# 1) In c√°c ∆∞·ªõc c·ªßa n\n# 2) ƒê·∫øm v√† in s·ªë l∆∞·ª£ng ∆∞·ªõc\n`,
      sampleInput:"6",
      hints:{
        level1:["∆Ø·ªõc l√† s·ªë chia h·∫øt n."],
        level2:["Duy·ªát i t·ª´ 1 ƒë·∫øn n, n·∫øu n % i == 0 th√¨ i l√† ∆∞·ªõc."],
        level3:["ƒê·∫øm s·ªë ∆∞·ªõc b·∫±ng bi·∫øn dem."],
        level4:["C√≥ th·ªÉ in ∆∞·ªõc ngay khi t√¨m th·∫•y."],
        level5:["N·∫øu FAIL: ki·ªÉm tra b·∫°n c√≥ in ƒë·ªß ∆∞·ªõc v√† in th√™m s·ªë l∆∞·ª£ng ·ªü cu·ªëi kh√¥ng."]
      },
      tests:{
        public:[
          {input:"6\n",expected:{n:6,divisors:[1,2,3,6],count:4}},
          {input:"1\n",expected:{n:1,divisors:[1],count:1}}
        ],
        hidden:[
          {input:"8\n",expected:{n:8,divisors:[1,2,4,8],count:4}},
          {input:"12\n",expected:{n:12,divisors:[1,2,3,4,6,12],count:6}}
        ]
      },
      checker:(out,expected)=>{
        const nums = (String(out??"").match(/-?\d+/g) || []).map(x=>Number(x));
        if(nums.length < (expected.divisors.length + 1)) return false;
        const last = nums[nums.length-1];
        if(last !== Number(expected.count)) return false;
        const set = new Set(nums.map(x=>String(x)));
        for(const d of expected.divisors){
          if(!set.has(String(d))) return false;
        }
        return true;
      },
      req:{ input:true, print:true, loop:true, if:true, math:true }
    },
    {
      id:"b16",
      group:"for",
      title:"B√†i 16: Ki·ªÉm tra s·ªë nguy√™n t·ªë",
      statement:"Nh·∫≠p s·ªë t·ª± nhi√™n n. In ra th√¥ng b√°o n c√≥ l√† s·ªë nguy√™n t·ªë hay kh√¥ng.",
      starter:`n = int(input("Nh·∫≠p n: "))\n\n# TODO: Ki·ªÉm tra n c√≥ ph·∫£i s·ªë nguy√™n t·ªë kh√¥ng\n`,
      sampleInput:"17",
      hints:{
        level1:["S·ªë nguy√™n t·ªë c√≥ ƒë√∫ng 2 ∆∞·ªõc: 1 v√† ch√≠nh n√≥."],
        level2:["N·∫øu n < 2 th√¨ kh√¥ng ph·∫£i s·ªë nguy√™n t·ªë."],
        level3:["Duy·ªát i t·ª´ 2 ƒë·∫øn sqrt(n), n·∫øu n%i==0 th√¨ kh√¥ng nguy√™n t·ªë."],
        level4:["D√πng bi·∫øn c·ªù (is_prime = True/False)."],
        level5:["N·∫øu FAIL: ki·ªÉm tra tr∆∞·ªùng h·ª£p n=0,1,2 v√† c√°ch d·ª´ng v√≤ng l·∫∑p."]
      },
      tests:{
        public:[{input:"2\n",expected:true},{input:"9\n",expected:false}],
        hidden:[{input:"1\n",expected:false},{input:"97\n",expected:true}]
      },
      checker:(out,expected)=>{
        const o=simplifyText(out);
        const yes = o.includes("nguyen to") || o.includes("prime") || o.trim()==="true" || o.trim()==="yes";
        const no  = o.includes("khong") || o.includes("not") || o.trim()==="false" || o.trim()==="no";
        return expected ? (yes && !no) : no;
      },
      req:{ input:true, print:true, loop:true, if:true }
    },

    // ====== C√ÇU L·ªÜNH while (5 b√†i) ======
    {
      id:"b17",
      group:"while",
      title:"B√†i 17: T·ªïng 1+2+3+... cho ƒë·∫øn khi > 100",
      statement:"Vi·∫øt ch∆∞∆°ng tr√¨nh t√≠nh t·ªïng s = 1 + 2 + 3 + ... cho ƒë·∫øn khi s > 100, r·ªìi in ra gi√° tr·ªã s.",
      starter:`# TODO: D√πng while ƒë·ªÉ c·ªông d·ªìn cho ƒë·∫øn khi s > 100\n`,
      sampleInput:"",
      hints:{
        level1:["B·∫°n c·∫ßn c·ªông d·ªìn 1,2,3,... cho ƒë·∫øn khi t·ªïng v∆∞·ª£t 100."],
        level2:["D√πng bi·∫øn i v√† s. Kh·ªüi t·∫°o i=1, s=0."],
        level3:["while s <= 100: s += i; i += 1"],
        level4:["K·∫øt th√∫c v√≤ng l·∫∑p, in s."],
        level5:["N·∫øu FAIL: ki·ªÉm tra ƒëi·ªÅu ki·ªán d·ª´ng (s > 100)."]
      },
      tests:{
        public:[{input:"",expected:105}],
        hidden:[{input:"",expected:105}]
      },
      checker:(out,expected)=>{
        const nums = (String(out??"").match(/-?\d+(\.\d+)?/g) || []).map(Number);
        return nums.includes(Number(expected));
      },
      req:{ input:false, print:true, loop:true, math:true }
    },
    {
      id:"b18",
      group:"while",
      title:"B√†i 18: S·ªë h·∫°ng l·ªõn nh·∫•t c·ªßa d√£y 1,4,7,10,... kh√¥ng v∆∞·ª£t qu√° 100",
      statement:"Vi·∫øt ch∆∞∆°ng tr√¨nh t√¨m s·ªë h·∫°ng l·ªõn nh·∫•t c·ªßa d√£y 1, 4, 7, 10, ... m√† kh√¥ng v∆∞·ª£t qu√° 100, r·ªìi in ra s·ªë ƒë√≥.",
      starter:`# TODO: D√£y 1,4,7,... c√≥ c√¥ng sai 3. D√πng while ƒë·ªÉ t√¨m s·ªë h·∫°ng l·ªõn nh·∫•t <=100\n`,
      sampleInput:"",
      hints:{
        level1:["D√£y tƒÉng th√™m 3 m·ªói l·∫ßn."],
        level2:["B·∫Øt ƒë·∫ßu x=1, m·ªói b∆∞·ªõc x += 3."],
        level3:["D·ª´ng khi x + 3 > 100."],
        level4:["In ra x sau khi k·∫øt th√∫c."],
        level5:["N·∫øu FAIL: ki·ªÉm tra b·∫°n c√≥ v∆∞·ª£t qu√° 100 kh√¥ng."]
      },
      tests:{
        public:[{input:"",expected:100}],
        hidden:[{input:"",expected:100}]
      },
      checker:(out,expected)=>{
        const nums = (String(out??"").match(/-?\d+(\.\d+)?/g) || []).map(Number);
        return nums.includes(Number(expected));
      },
      req:{ input:false, print:true, loop:true, math:true }
    },
    {
      id:"b19",
      group:"while",
      title:"B√†i 19: T·ªïng v√† s·ªë l∆∞·ª£ng s·ªë ch·∫µn t·ª´ 0 ƒë·∫øn 99",
      statement:"T√≠nh t·ªïng v√† ƒë·∫øm s·ªë l∆∞·ª£ng c√°c s·ªë ch·∫µn trong d√£y 100 s·ªë t·ª± nhi√™n ƒë·∫ßu ti√™n (t·ª´ 0 ƒë·∫øn 99). In ra l·∫ßn l∆∞·ª£t: t·ªïng r·ªìi ƒë·∫øn s·ªë l∆∞·ª£ng.",
      starter:`# TODO: D√πng while/for ƒë·ªÅu ƒë∆∞·ª£c, nh∆∞ng ∆∞u ti√™n while theo y√™u c·∫ßu\n`,
      sampleInput:"",
      hints:{
        level1:["S·ªë ch·∫µn: 0,2,4,...,98."],
        level2:["C√≥ 50 s·ªë ch·∫µn trong 0..99."],
        level3:["Duy·ªát i t·ª´ 0..99, n·∫øu i%2==0 th√¨ c·ªông v√† ƒë·∫øm."],
        level4:["In ra: t·ªïng v√† s·ªë l∆∞·ª£ng."],
        level5:["N·∫øu FAIL: ki·ªÉm tra b·∫°n c√≥ duy·ªát ƒë√∫ng 0..99 v√† ch·ªâ l·∫•y s·ªë ch·∫µn kh√¥ng."]
      },
      tests:{
        public:[{input:"",expected:{sum:2450,count:50}}],
        hidden:[{input:"",expected:{sum:2450,count:50}}]
      },
      checker:(out,expected)=>{
        const nums = (String(out??"").match(/-?\d+/g) || []).map(Number);
        if(nums.length < 2) return false;
        return nums[0]===Number(expected.sum) && nums[1]===Number(expected.count);
      },
      req:{ input:false, print:true, loop:true, if:true, math:true }
    },
    {
      id:"b20",
      group:"while",
      title:"B√†i 20: ƒê·∫øm s·ªë ch·ªØ s·ªë c·ªßa n",
      statement:"Nh·∫≠p m·ªôt s·ªë nguy√™n d∆∞∆°ng n, ƒë·∫øm v√† in ra s·ªë ch·ªØ s·ªë c·ªßa n. V√≠ d·ª•: n=1023 ‚Üí 4.",
      starter:`n = int(input("Nh·∫≠p n: "))\n\n# TODO: ƒê·∫øm s·ªë ch·ªØ s·ªë c·ªßa n v√† in ra\n`,
      sampleInput:"1023",
      hints:{
        level1:["B·∫°n c√≥ th·ªÉ t√°ch t·ª´ng ch·ªØ s·ªë b·∫±ng c√°ch chia 10."],
        level2:["L·∫∑p: n //= 10 v√† tƒÉng ƒë·∫øm cho ƒë·∫øn khi n == 0."],
        level3:["Nh·ªõ x·ª≠ l√Ω n>0."],
        level4:["Ho·∫∑c ƒë·ªïi sang chu·ªói r·ªìi l·∫•y len(str(n))."],
        level5:["N·∫øu FAIL: ki·ªÉm tra v√≤ng l·∫∑p v√† tr∆∞·ªùng h·ª£p n c√≥ 1 ch·ªØ s·ªë."]
      },
      tests:{
        public:[{input:"1023\n",expected:4},{input:"7\n",expected:1}],
        hidden:[{input:"99999\n",expected:5},{input:"10\n",expected:2}]
      },
      checker:(out,expected)=>{
        const got = extractFirstNumber(out);
        return got!==null && Math.round(got)===Number(expected);
      },
      req:{ input:true, print:true, loop:true, math:true }
    },
    {
      id:"b21",
      group:"while",
      title:"B√†i 21: S·ªë ngh·ªãch ƒë·∫£o c·ªßa n",
      statement:"Nh·∫≠p m·ªôt s·ªë nguy√™n d∆∞∆°ng n, in ra s·ªë ngh·ªãch ƒë·∫£o c·ªßa n. V√≠ d·ª•: n=123 ‚Üí 321.",
      starter:`n = int(input("Nh·∫≠p n: "))\n\n# TODO: T√≠nh s·ªë ngh·ªãch ƒë·∫£o c·ªßa n v√† in ra\n`,
      sampleInput:"123",
      hints:{
        level1:["B·∫°n c·∫ßn ƒë·∫£o th·ª© t·ª± c√°c ch·ªØ s·ªë."],
        level2:["D√πng ph√©p %10 ƒë·ªÉ l·∫•y ch·ªØ s·ªë cu·ªëi, v√† //10 ƒë·ªÉ b·ªè ch·ªØ s·ªë cu·ªëi."],
        level3:["C√¥ng th·ª©c: rev = rev*10 + digit."],
        level4:["L·∫∑p ƒë·∫øn khi n==0."],
        level5:["N·∫øu FAIL: ki·ªÉm tra b·∫°n c·∫≠p nh·∫≠t n v√† rev ƒë√∫ng th·ª© t·ª±."]
      },
      tests:{
        public:[{input:"123\n",expected:321},{input:"1023\n",expected:3201}],
        hidden:[{input:"100\n",expected:1},{input:"9070\n",expected:709}]
      },
      checker:(out,expected)=>{
        const got = extractFirstNumber(out);
        return got!==null && Math.round(got)===Number(expected);
      },
      req:{ input:true, print:true, loop:true, math:true }
    },
  ];

  // Danh sach bai dung thuc te trong editor (dong): 5 bai co san + bai GV giao (Bai 6+)
  // Dung "let" de co the rebuild khi GV giao them bai.
  let PROBLEMS = BASE_PROBLEMS.slice();

  // ====== B√†i gi√°o vi√™n giao (append sau 21 b√†i c√≥ s·∫µn) ======
  // Multi-teacher: b√†i GV giao / ƒë·ªÅ ri√™ng ƒë∆∞·ª£c l∆∞u theo namespace c·ªßa GV.
  // - GV: teacherScope = session.id
  // - HS: teacherScope = session.teacherId (ƒë∆∞·ª£c set l√∫c ƒëƒÉng nh·∫≠p)
  // Fallback: n·∫øu thi·∫øu teacherId th√¨ d√πng "gv".
  const DEFAULT_TEACHER_ID = "gv";
  function _getTeacherScope(){
    try{
      const s = getSession();
      if(s && s.role === "teacher" && s.id) return String(s.id).trim();
      if(s && s.teacherId) return String(s.teacherId).trim();
      // Backward compatibility: try infer from studentIndex
      if(s && s.role === "student" && s.id){
        try{
          const idxRaw = JSON.parse(localStorage.getItem("py10:studentIndex")||"null");
          const map = idxRaw && idxRaw.map ? idxRaw.map : idxRaw;
          const tid = map ? String(map[String(s.id).trim()]||"").trim() : "";
          if(tid) return tid;
        }catch(e){}
      }
    }catch(e){}
    return DEFAULT_TEACHER_ID;
  }
  const _teacherScope = _getTeacherScope();
  const ASSIGN_KEY = `py10:${_teacherScope}:assignments`;
  const TEACHER_BANK_KEY = `py10:${_teacherScope}:teacherBank`;
  const ROSTER_KEY = `py10:${_teacherScope}:roster`;

  function _loadJSON(key, fallback){
    try{
      const v = JSON.parse(localStorage.getItem(key) || "null");
      return (v === null || v === undefined) ? fallback : v;
    }catch(_){
      return fallback;
    }
  }

  function assignmentMatchesStudent(a, sess){
    try{
      if(!a || a.active === false) return false;
      if(!sess || sess.role !== "student") return false;

      const sid = String(sess.id || "").trim();
      let cls = String(sess.class || sess.cls || "").trim();

      // Fallback: n·∫øu session kh√¥ng c√≥ l·ªõp, th·ª≠ ƒë·ªçc t·ª´ roster c·ªßa GV (multi-teacher)
      if(!cls){
        try{
          let roster = _loadJSON(ROSTER_KEY, null);
          // legacy compatibility (single-class builds)
          if(!roster && _teacherScope === DEFAULT_TEACHER_ID){
            roster = _loadJSON("py10:roster", null);
          }
          if(roster && Array.isArray(roster.students)){
            const st = roster.students.find(s => String(s.id||"").trim() === sid);
            if(st) cls = String(st.class || st.cls || "").trim();
          }
        }catch(e){}
      }

      // legacy: a.target = "all" | "class:10A1" | "student:hs1"
      if(typeof a.target === "string"){
        const t = a.target.trim();
        if(t === "all" || t === "everyone") return true;
        if(t.startsWith("class:")) return t.slice(6).trim() === cls;
        if(t.startsWith("student:")) return t.slice(8).trim() === sid;
      }

      const type = String(a.targetType || a.type || "all").toLowerCase();
      if(type === "all" || type === "everyone") return true;

      if(type === "class"){
        const v = String(a.targetValue || a.className || a.class || "").trim();
        return !!v && v === cls;
      }

      if(type === "students" || type === "student"){
        const direct = String(a.targetValue || "").trim();
        if(direct && direct === sid) return true;
        const arr = a.targets || a.studentIds || a.students || [];
        if(Array.isArray(arr)) return arr.map(x=>String(x).trim()).includes(sid);
        return false;
      }

      // fallback: targets array may contain sid
      if(Array.isArray(a.targets)){
        const arr = a.targets.map(x=>String(x).trim());
        return arr.includes(sid);
      }

      return false;
    }catch(e){
      return false;
    }
  }

  function formatDue(iso){
    if(!iso) return "";
    try{
      const d = new Date(String(iso));
      if(isNaN(d.getTime())) return String(iso);
      const dd = String(d.getDate()).padStart(2,"0");
      const mm = String(d.getMonth()+1).padStart(2,"0");
      const yy = d.getFullYear();
      return `${dd}/${mm}/${yy}`;
    }catch(_){
      return String(iso);
    }
  }

  function buildProblemFromTeacherBank(bankItem, meta){
    const b = bankItem || {};
    const id = String(b.id || "").trim();
    if(!id) return null;

    const titleRaw = String(meta?.title || b.title || ("B√†i GV " + id)).trim();
    const text = String(b.text || b.statement || "").trim();
    const note = String(meta?.note || "").trim();
    const due = String(meta?.due || "").trim();

    let statement = text || "ƒê·ªÅ b√†i (gi√°o vi√™n giao)";
    const extra = [];
    if(note) extra.push("Ghi ch√∫ gi√°o vi√™n: " + note);
    if(due) extra.push("H·∫°n: " + formatDue(due));
    if(extra.length) statement += "\n\n" + extra.join("\n");
    // Tests: ∆∞u ti√™n b.tests[]; fallback sampleIn/sampleOut
    let testList = [];
    if(Array.isArray(b.tests) && b.tests.length){
      testList = b.tests
        .map(t => ({
          input: String(t.stdin ?? t.input ?? ""),
          expected: (t.expected ?? t.output ?? "")
        }))
        .filter(t => String(t.input).length || String(t.expected).length);
    }
    if(!testList.length){
      const inp = String(b.sampleIn ?? b.sampleInput ?? "");
      const exp = String(b.sampleOut ?? b.sampleOutput ?? "");
      if(inp.length || exp.length) testList = [{ input: inp, expected: exp }];
    }
    if(!testList.length){
      // tr√°nh auto-pass khi thi·∫øu test
      testList = [{ input: "", expected: "__MISSING_EXPECTED__" }];
    }

    const starter = (String(b.starter || "").trim())
      ? String(b.starter)
      : `# ${titleRaw}
# Vi·∫øt code c·ªßa b·∫°n ·ªü ƒë√¢y
`;

    const sampleInput = String(b.sampleIn ?? b.sampleInput ?? "");

    return {
      id,
      title: titleRaw, // ti√™u ƒë·ªÅ hi·ªÉn th·ªã
      statement,
      starter,
      sampleInput,
      hints:{
        level1:["ƒê·ªçc k·ªπ ƒë·ªÅ v√† vi·∫øt t·ª´ng b∆∞·ªõc."],
        level2:["Chia nh·ªè: nh·∫≠p ‚Üí x·ª≠ l√Ω ‚Üí in k·∫øt qu·∫£."],
        level3:["Ch√∫ √Ω ƒë·ªãnh d·∫°ng output (d·∫•u c√°ch, xu·ªëng d√≤ng)."],
        level4:["Th·ª≠ v·ªõi sample tr∆∞·ªõc r·ªìi m·ªõi Test."],
        level5:["N·∫øu FAIL: so s√°nh output c·ªßa b·∫°n v·ªõi expected."],
      },
      tests:{
        public: testList.map(t=>({ input: String(t.input??""), expected: t.expected })),
        hidden:[]
      },
      checker:(out, expected)=>{
        // Ch·∫•m b√†i GV giao: ∆∞u ti√™n ƒë√∫ng n·ªôi dung, kh√¥ng b·∫Øt l·ªói do kh√°c d·∫•u c√°ch/xu·ªëng d√≤ng.
        const oRaw = normalizeOutput(out);
        const eRaw = normalizeOutput(String(expected ?? ""));
        const o = oRaw.trim();
        const e = eRaw.trim();
        if(o === e) return true;

        // So s√°nh theo token (b·ªè kh√°c bi·ªát whitespace)
        const ot = tokenize(oRaw);
        const et = tokenize(eRaw);
        if(ot.length === et.length){
          let same = true;
          for(let i=0;i<ot.length;i++){ if(ot[i] !== et[i]){ same=false; break; } }
          if(same) return true;
        }

        // N·∫øu expected ch·ªâ l√† 1 s·ªë: cho ph√©p so s√°nh s·ªë (h·∫°n ch·∫ø sai do .0)
        const expNum = extractFirstNumber(eRaw);
        if(expNum !== null && et.length === 1){
          const gotNum = extractFirstNumber(oRaw);
          if(gotNum !== null && Math.abs(gotNum - expNum) < 1e-9) return true;
        }

        return false;
      }
    };
  }

  
function rebuildProblemsFromAssignments(){
  const base = BASE_PROBLEMS.slice();

  // ch·ªâ h·ªçc sinh m·ªõi c·∫ßn ch√®n b√†i GV giao
  if(!_sess || _sess.role !== "student"){
    PROBLEMS = base;
    return;
  }

  const assignsAll = _loadJSON(ASSIGN_KEY, []) || [];
  const assigns = assignsAll
    .filter(a=>a && a.active !== false)
    .filter(a=>assignmentMatchesStudent(a, _sess));

  const bank = _loadJSON(TEACHER_BANK_KEY, []) || [];
  const bankMap = new Map((Array.isArray(bank)?bank:[])
    .filter(x=>x && x.id)
    .map(x=>[String(x.id).trim(), x]));

  // Placement (M·ª•c/C√¢u): cho ph√©p GV ch√®n b√†i v√†o ƒë√∫ng m·ª•c + th·ª© t·ª± c√¢u
  const normPlaceGroup = (v)=>{
    const s0 = String(v||"").trim().toLowerCase();
    if(!s0) return "";
    const s = s0
      .normalize("NFD").replace(/[\u0300-\u036f]/g,"")
      .replace(/\s+/g," ")
      .trim();
    if(s === "1" || s === "muc1" || s === "muc 1" || s.includes("vao/ra") || s.includes("vao ra") || s === "io") return "io";
    if(s === "2" || s === "muc2" || s === "muc 2" || s === "if" || s.includes("cau lenh if")) return "if";
    if(s === "3" || s === "muc3" || s === "muc 3" || s === "for") return "for";
    if(s === "4" || s === "muc4" || s === "muc 4" || s === "while") return "while";
    if(s === "gv" || s.includes("giao vien") || s.includes("bai gv") || s.includes("gv giao")) return "gv";
    if(["io","if","for","while","gv"].includes(s)) return s;
    return "";
  };
  const normPlaceIndex = (v)=>{
    const n = parseInt(String(v??"").trim(), 10);
    return Number.isFinite(n) && n>0 ? n : null;
  };
  const groupOrder = { io:1, if:2, for:3, while:4, gv:5 };

  // sort ∆∞u ti√™n theo v·ªã tr√≠ (m·ª•c/c√¢u), sau ƒë√≥ theo h·∫°n
  const sorted = assigns.slice().sort((a,b)=>{
    const ag = normPlaceGroup(a.placeGroup || a.group) || "gv";
    const bg = normPlaceGroup(b.placeGroup || b.group) || "gv";
    const ao = groupOrder[ag] ?? 99;
    const bo = groupOrder[bg] ?? 99;
    if(ao !== bo) return ao - bo;

    const ai = normPlaceIndex(a.placeIndex) ?? 9999;
    const bi = normPlaceIndex(b.placeIndex) ?? 9999;
    if(ai !== bi) return ai - bi;

    const ad = String(a.due || "9999-12-31");
    const bd = String(b.due || "9999-12-31");
    if(ad !== bd) return ad.localeCompare(bd);

    const ac = String(a.createdAt || "");
    const bc = String(b.createdAt || "");
    return ac.localeCompare(bc);
  });

  const seen = new Set(base.map(p=>p.id));
  const list = base.slice();

  function insertIntoGroup(arr, prob, gid, pos){
    const g = normPlaceGroup(gid) || "gv";
    const p = normPlaceIndex(pos);

    // n·∫øu group kh√¥ng t·ªìn t·∫°i (hi·∫øm) -> ƒë·∫©y xu·ªëng cu·ªëi
    const idxs = [];
    for(let i=0;i<arr.length;i++){
      if(arr[i] && arr[i].group === g) idxs.push(i);
    }
    if(!idxs.length){
      arr.push(prob);
      return;
    }

    const start = idxs[0];
    const count = idxs.length;
    const end = idxs[count-1] + 1;

    let ins = end;
    if(p !== null){
      const offset = Math.max(0, Math.min(p - 1, count)); // cho ph√©p ch√®n cu·ªëi nh√≥m
      ins = start + offset;
    }
    arr.splice(ins, 0, prob);
  }

  for(const a of sorted){
    const lessonId = String(a.lessonId || "").trim();
    if(!lessonId) continue;
    if(seen.has(lessonId)) continue;

    const bankItem = bankMap.get(lessonId);
    if(!bankItem) continue;

    const prob = buildProblemFromTeacherBank(bankItem, { title: a.title, note: a.note, due: a.due });
    if(!prob) continue;

    const pg = normPlaceGroup(a.placeGroup || a.group || bankItem.group) || "gv";
    prob.group = pg;
    try{
      prob.__assign = { id:a.id, due:a.due||"", note:a.note||"", placeGroup: pg, placeIndex: a.placeIndex||"" };
    }catch(e){}

    insertIntoGroup(list, prob, pg, a.placeIndex);
    seen.add(lessonId);
  }

  PROBLEMS = list;
  // ƒê·∫£m b·∫£o "N·∫°p khung" ƒë√∫ng nghƒ©a l√† KHUNG, kh√¥ng ch√®n code m·∫´u.
  applyNoCodeStarterToList(PROBLEMS);
}

// Build ngay khi load trang (khong de loi lam treo editor)
  try{
    rebuildProblemsFromAssignments();
  }catch(e){
    console.error("rebuildProblemsFromAssignments error", e);
    PROBLEMS = BASE_PROBLEMS.slice();
  }

  // D√π ch·∫°y nh√°nh n√†o th√¨ c≈©ng √©p starter v·ªÅ "khung" (kh√¥ng c√≥ code m·∫´u).
  applyNoCodeStarterToList(PROBLEMS);

  // =======================
  // Progress lock (scope theo user)
  // =======================
  const PROGRESS_KEY = `py10:${_scope}:progress_pass_v1`;
  function loadProgress(){
    try{
      const v = JSON.parse(localStorage.getItem(PROGRESS_KEY) || "null");
      return v && typeof v === "object" ? v : { passed:{} };
    }catch(_){ return { passed:{} }; }
  }
  function saveProgress(p){ try{ localStorage.setItem(PROGRESS_KEY, JSON.stringify(p)); }catch(_){}}
  

  // =======================
  // ƒê·ªìng b·ªô K·∫æT QU·∫¢ cho Gi√°o vi√™n (shared keys)
  // Gi√°o vi√™n ƒë·ªçc: py10:progress:<hsid> v√† py10:log:<hsid>
  // =======================
  const T_PROG_KEY = `py10:progress:${_scope}`;
  const T_LOG_KEY  = `py10:log:${_scope}`;
  function tLoadJSON(key, fallback){
    try{ const v = JSON.parse(localStorage.getItem(key) || 'null'); return (v && typeof v==='object') ? v : fallback; }
    catch(_){ return fallback; }
  }
  function tSaveJSON(key, val){ try{ localStorage.setItem(key, JSON.stringify(val)); }catch(_){} }
  function tLoadProg(){
    const p = tLoadJSON(T_PROG_KEY, {passed:{}, lastSavedAt:null});
    if(!p.passed || typeof p.passed!=='object') p.passed = {};
    return p;
  }
  function tLoadLog(){
    const l = tLoadJSON(T_LOG_KEY, {events:[]});
    if(!Array.isArray(l.events)) l.events = [];
    return l;
  }
  function tPushEvent(ev){
    const l = tLoadLog();
    l.events.push(ev);
    if(l.events.length > 300) l.events = l.events.slice(-300);
    tSaveJSON(T_LOG_KEY, l);
  }
  function syncTeacherResult({ok, lessonId, err, act='test', code, stdin, stdout}){
    const now = new Date().toISOString();
    const prog = tLoadProg();
    if(ok) prog.passed[String(lessonId)] = true;
    prog.lastSavedAt = now;
    tSaveJSON(T_PROG_KEY, prog);
    tPushEvent({at: now, act, ok: !!ok, lessonId: String(lessonId), err: err ? String(err) : ''});
    // Firebase sync (optional)
    try{
      if(window.py10Firebase && window.py10Firebase.enabled){
        window.py10Firebase.pushResult({ studentId: _scope, lessonId: String(lessonId), ok: !!ok, err: err ? String(err) : '', act: act || 'test', at: now });
        if(typeof window.py10Firebase.pushSubmission === 'function'){
          window.py10Firebase.pushSubmission({ studentId: _scope, lessonId: String(lessonId), ok: !!ok, err: err ? String(err) : '', act: act || 'test', at: now, code: code || '', stdin: stdin || '', stdout: stdout || '' });
        }
      }
    }catch(e){}
  }
function indexOfProblem(id){ return PROBLEMS.findIndex(p=>p.id===id); }
  function isUnlockedByIndex(idx, progress){
    if(idx <= 0) return true;
    const prevId = PROBLEMS[idx-1].id;
    return !!(progress && progress.passed && progress.passed[prevId]);
  }
  function isUnlockedById(id, progress){ return isUnlockedByIndex(indexOfProblem(id), progress); }

  // =======================
  // Auto-save theo t·ª´ng b√†i (scope theo user)
  // =======================
  const CODE_KEY_PREFIX = `py10:${_scope}:code_v1_`;
  function loadSavedCode(problemId){
    try{
      const v = localStorage.getItem(CODE_KEY_PREFIX + problemId);
      return (v === null) ? null : v;
    }catch(_){ return null; }
  }

  // N·∫øu HS ƒë√£ m·ªü b√†i tr∆∞·ªõc ƒë√≥, h·ªá th·ªëng c√≥ th·ªÉ ƒë√£ auto-save "khung" c≈©.
  // M·ª•c ti√™u: khi quay l·∫°i b√†i, n·∫øu ph·∫ßn l∆∞u ch·ªâ l√† KHUNG (ch∆∞a c√≥ code th·∫≠t),
  // th√¨ lu√¥n d√πng KHUNG m·ªõi theo ƒë√∫ng b√†i, ƒë·ªÉ tr√°nh b·ªã "khung chung" d√≠nh l·∫°i.
  function _hasNonCommentCode(code){
    const s = String(code || "");
    const lines = s.split(/\r?\n/);
    for(const line of lines){
      const t = String(line || "").trim();
      if(!t) continue;
      if(t.startsWith('#')) continue; // ch·ªâ l√† comment
      return true; // c√≥ d√≤ng code th·∫≠t
    }
    return false;
  }
  function _isOnlySavedScaffold(code){
    const s = String(code || "");
    const hasOldMarker = /KHUNG\s+L√ÄM\s+B√ÄI/i.test(s);
    const hasNewMarker =
      /^\s*#\s*Nh·∫≠p\s*:/mi.test(s) &&
      /^\s*#\s*X·ª≠\s*l√Ω\s*:/mi.test(s) &&
      /^\s*#\s*In\s*:/mi.test(s);

    if(!(hasOldMarker || hasNewMarker)) return false;
    return !_hasNonCommentCode(s);
  }
  function saveCode(problemId, code){ try{ localStorage.setItem(CODE_KEY_PREFIX + problemId, code ?? ""); }catch(_){}}
  let saveTimer = null;
  function scheduleSave(){
    if(saveTimer) clearTimeout(saveTimer);
    saveTimer = setTimeout(()=>{ saveCode(state.currentId, getCode()); }, 250);
  }

  // =======================
  // UI + State
  // =======================
  const elStdin = document.getElementById("stdin");
  const elOut = document.getElementById("out");
  const elRun = document.getElementById("runBtn");
  const elRunOnly = document.getElementById("runOnlyBtn");
  const elNext = document.getElementById("nextBtn");
  const elHint = document.getElementById("hintBtn");
  const elLoad = document.getElementById("loadBtn");
  const elStatus = document.getElementById("status");
  const elSelect = document.getElementById("problemSelect");
  const elGroup = document.getElementById("groupSelect");
  const elGroupOverlay = document.getElementById("groupOverlay");
  const elPractice = document.getElementById("practiceBtn");
  const elSmallBtn = document.getElementById("smallBtn");
  const elPill = document.getElementById("pill");
  const elScoreMeta = document.getElementById("scoreMeta");
  const elSubtitle = document.getElementById("subtitle");
  const elCoachNext = document.getElementById("coachNext");
  const elCoachChecklist = document.getElementById("coachChecklist");
  const elStatementTitle = document.getElementById("statementTitle");
  const elStatementText = document.getElementById("statementText");

  // =======================
  // Pretest Gate (√¥n luy·ªán b·∫Øt bu·ªôc tr∆∞·ªõc khi code)
  // - M·ªói b√†i l·ªõn c√≥ th·ªÉ c√≥ 1 ho·∫∑c nhi·ªÅu b√†i √¥n luy·ªán (HTML) ph·∫£i l√†m tr∆∞·ªõc khi code.
  // - Tr·∫°ng th√°i l∆∞u theo h·ªçc sinh (scope theo t√†i kho·∫£n ƒëƒÉng nh·∫≠p).
  // - M·∫∑c ƒë·ªãnh: B√†i l·ªõn 1 (V√†o/ra) y√™u c·∫ßu l√†m B√†i 1 + B√†i 2 (ƒë·ªÉ d√πng ƒë·ªß 5 file √¥n luy·ªán b·∫°n ƒë∆∞a).
  //   N·∫øu b·∫°n mu·ªën ƒë∆°n gi·∫£n h∆°n (ch·ªâ y√™u c·∫ßu 1 b√†i/1 b√†i l·ªõn), s·ª≠a c·∫•u h√¨nh PRETEST_CFG b√™n d∆∞·ªõi.
  // =======================
  const elPretestBtn = document.getElementById("pretestBtn");
  const elPretestRow = document.getElementById("pretestRow");
  const elPretestModal = document.getElementById("pretestModal");
  const elPretestBackdrop = document.getElementById("pretestBackdrop");
  const elPretestClose = document.getElementById("pretestClose");
  const elPretestTitle = document.getElementById("pretestTitle");
  const elPretestSub = document.getElementById("pretestSub");
  const elPretestFrame = document.getElementById("pretestFrame");

  // =======================
  // Pretest modal close control
  // - M·∫∑c ƒë·ªãnh KH√îNG cho tho√°t khi ƒëang l√†m b√†i √¥n luy·ªán.
  // - Ch·ªâ cho ph√©p tho√°t (hi·ªán n√∫t X / click n·ªÅn ƒë·ªÉ ƒë√≥ng) khi trang b√†i ki·ªÉm tra
  //   trong iframe g·ª≠i message: {type:'py10_pretest_can_close', canClose:true}.
  // =======================
  let __pretestCanClose = false;
  function setPretestClosable(canClose){
    __pretestCanClose = !!canClose;
    try{
      if(elPretestClose) elPretestClose.style.display = __pretestCanClose ? 'inline-flex' : 'none';
    }catch(e){}
  }

  const PRETEST_CFG = {
    io: [
      { id: "b1", title: "√în luy·ªán b·∫Øt bu·ªôc: B√†i 1 ‚Äî Bi·∫øn v√† l·ªánh g√°n", file: "./onluyen/kiem_tra_bai1.html" },
      { id: "b2", title: "√în luy·ªán b·∫Øt bu·ªôc: B√†i 2 ‚Äî C√°c l·ªánh v√†o/ra ƒë∆°n gi·∫£n", file: "./onluyen/kiem_tra_bai2.html" },
    ],
    if: [
      { id: "b3", title: "√în luy·ªán b·∫Øt bu·ªôc: B√†i 3 ‚Äî C√¢u l·ªánh if", file: "./onluyen/kiem_tra_bai3.html" },
    ],
    for: [
      { id: "b4", title: "√în luy·ªán b·∫Øt bu·ªôc: B√†i 4 ‚Äî V√≤ng l·∫∑p for", file: "./onluyen/kiem_tra_bai4.html" },
    ],
    while: [
      { id: "b5", title: "√în luy·ªán b·∫Øt bu·ªôc: B√†i 5 ‚Äî V√≤ng l·∫∑p while", file: "./onluyen/kiem_tra_bai5.html" },
    ],
    // gv: []  // B√†i GV giao: m·∫∑c ƒë·ªãnh kh√¥ng b·∫Øt bu·ªôc √¥n luy·ªán
  };

  let ENGINE_READY = false; // b·∫≠t true khi Pyodide load xong
  let __gateLocked = false;
  let __gateWasLocked = false;
  let __desiredReadOnly = false;

  function _safeGetLS(k){ try{ return localStorage.getItem(k); }catch(e){ return null; } }

  function pretestKey(testId){
    return `py10:pretest:${_scope}:${testId}:passed`;
  }

  // M·ªôt s·ªë lu·ªìng/b·∫£n ch·ªâ l∆∞u k·∫øt qu·∫£ theo key :result (k·ªÉ c·∫£ ƒë√£ ƒë·∫°t),
  // nh∆∞ng key :passed (marker m·ªü kh√≥a) c√≥ th·ªÉ ch∆∞a c√≥/kh√¥ng ƒë∆∞·ª£c ƒë·ªìng b·ªô.
  // => N·∫øu c√≥ :result.passed=true th√¨ coi nh∆∞ ƒë√£ ƒë·∫°t v√† t·ª± "t·ª± ch·ªØa" b·∫±ng c√°ch t·∫°o :passed.
  function pretestResultKey(testId){
    return `py10:pretest:${_scope}:${testId}:result`;
  }

  function _readJSONLS(key){
    try{
      const raw = _safeGetLS(key);
      if(!raw) return null;
      return JSON.parse(raw);
    }catch(e){
      return null;
    }
  }

  function isPretestPassed(testId){
    // 1) ∆Øu ti√™n marker :passed (nhanh + ƒë√∫ng m·ª•c ƒë√≠ch m·ªü kh√≥a)
    const raw = _safeGetLS(pretestKey(testId));
    if(raw){
      try{
        const obj = JSON.parse(raw);
        if(obj && obj.passed) return true;
      }catch(e){
        if(raw === "1" || raw === "true") return true;
      }
    }

    // 2) Fallback: n·∫øu ƒë√£ c√≥ :result v√† (everPassed/passed)=true th√¨ c≈©ng coi l√† ƒë·∫°t
    const r = _readJSONLS(pretestResultKey(testId));
    if(r && (r.everPassed || r.passed)){
      // t·ª± t·∫°o marker :passed ƒë·ªÉ l·∫ßn sau kh√¥ng b·ªã "b·∫Øt l√†m l·∫°i" n·ªØa
      try{
        const ts = (r.ts !== undefined && r.ts !== null) ? r.ts : Date.now();
        const scoreRaw = (r.bestScore !== undefined && r.bestScore !== null) ? r.bestScore : r.score;
        const payload = { passed:true, score: (scoreRaw===undefined?null:Number(scoreRaw||0)), ts };
        localStorage.setItem(pretestKey(testId), JSON.stringify(payload));
      }catch(e){}
      return true;
    }

    return false;
  }

  function gateInfoForGroup(groupId){
    const sess = getSession();
    const isStudent = !!(sess && sess.role === 'student');
    if(!isStudent) return { locked:false, req:[], missing:null, done:0, total:0 };

    const req = PRETEST_CFG[groupId] || [];
    if(!req.length) return { locked:false, req, missing:null, done:0, total:req.length };

    const done = req.filter(t => isPretestPassed(t.id)).length;
    const missing = req.find(t => !isPretestPassed(t.id)) || null;
    return { locked: !!missing, req, missing, done, total: req.length };
  }

  function currentGroupId(){
    const p = currentProblem();
    return (p && p.group) ? p.group : "";
  }

  function applyEditorReadOnly(){
    try{ if(editor) editor.updateOptions({ readOnly: __desiredReadOnly }); }catch(e){}
  }

  function syncGateControls(){
    const locked = __gateLocked;
    const ready = ENGINE_READY;
    if(elLoad) elLoad.disabled = !ready || locked;
    if(elHint) elHint.disabled = !ready || locked;
    if(elRunOnly) elRunOnly.disabled = !ready || locked;
    if(elRun) elRun.disabled = !ready || locked;
    if(elNext) elNext.disabled = !ready || locked;
  }

  function applyPretestGate(){
    const gid = currentGroupId();
    const info = gateInfoForGroup(gid);

    __gateWasLocked = __gateLocked;
    __gateLocked = !!info.locked;

    if(elPretestBtn){
      if(__gateLocked){
        elPretestBtn.style.display = 'inline-flex';
        elPretestBtn.textContent = `√în luy·ªán b·∫Øt bu·ªôc ‚Ä¢ ${info.done}/${info.total}`;
        elPretestBtn.title = info.missing ? info.missing.title : 'B√†i t·∫≠p √¥n luy·ªán';
      }else{
        elPretestBtn.style.display = 'none';
      }
      try{ if(elPretestRow) elPretestRow.style.display = __gateLocked ? 'flex' : 'none'; }catch(e){}
    }

    __desiredReadOnly = __gateLocked;
    applyEditorReadOnly();
    syncGateControls();

    if(__gateLocked){
      try{
        const need = info.missing ? info.missing.title : 'B√†i t·∫≠p √¥n luy·ªán';
        setOutHTML(
          `<span class="x">üîí Ch∆∞a th·ªÉ code.</span>
`+
          `<span class="hint">B·∫°n c·∫ßn l√†m: <b>${escapeHTML(need)}</b> v√† ƒë·∫°t ‚â• 7.0 ƒëi·ªÉm.</span>
`+
          `<span class="muted">B·∫•m n√∫t ‚Äú√în luy·ªán b·∫Øt bu·ªôc‚Äù (ngay d∆∞·ªõi thanh ch·ªçn b√†i) ƒë·ªÉ m·ªü.</span>`
        );
      }catch(e){}
      try{ if(elCoachNext) elCoachNext.textContent = "üîí H√£y l√†m b√†i √¥n luy·ªán tr∆∞·ªõc khi code."; }catch(e){}
    }else if(__gateWasLocked){
      try{ setOutHTML(`<span class="ok">‚úÖ ƒê√£ m·ªü kh√≥a ph·∫ßn code.</span>
<span class="muted">B√¢y gi·ªù b·∫°n c√≥ th·ªÉ vi·∫øt code v√† b·∫•m Test.</span>`); }catch(e){}
      try{ updateCoach(); }catch(e){}
    }
  }

  function openPretestModal(){
    const gid = currentGroupId();
    const info = gateInfoForGroup(gid);
    if(!info.missing) return;
    const t = info.missing;

    if(elPretestTitle) elPretestTitle.textContent = t.title;
    if(elPretestSub) elPretestSub.textContent = 'L√†m xong v√† ƒë·∫°t y√™u c·∫ßu th√¨ h·ªá th·ªëng s·∫Ω m·ªü kh√≥a ph·∫ßn code.';

    if(elPretestFrame){
      // D√πng ƒë∆∞·ªùng d·∫´n t∆∞∆°ng ƒë·ªëi ƒë·ªÉ ch·∫°y ·ªïn c·∫£ khi m·ªü b·∫±ng file:/// l·∫´n khi deploy l√™n web
      elPretestFrame.src = t.file + "?v=" + Date.now();
    }

    // Khi m·ªü b√†i: m·∫∑c ƒë·ªãnh KH√îNG cho tho√°t.
    setPretestClosable(false);

    if(elPretestModal){
      elPretestModal.style.display = 'block';
      elPretestModal.setAttribute('aria-hidden','false');
    }
  }

  
  function openPracticeModal(){
    // √în luy·ªán t·ªïng h·ª£p: tr·ªôn c√¢u h·ªèi t·ª´ B√†i 1 ‚Üí 5 (15 tr·∫Øc nghi·ªám + 5 ƒë√∫ng/sai)
    if(elPretestTitle) elPretestTitle.textContent = "√în luy·ªán t·ªïng h·ª£p (B√†i 1‚Äì5)";
    if(elPretestSub) elPretestSub.textContent = "ƒê·ªÅ tr·ªôn 5 b√†i: 15 c√¢u tr·∫Øc nghi·ªám + 5 c√¢u ƒë√∫ng/sai. B·∫°n c√≥ th·ªÉ b·∫•m ‚ÄúT·∫†O ƒê·ªÄ M·ªöI‚Äù ƒë·ªÉ tr·ªôn l·∫°i.";
    if(elPretestFrame){
      elPretestFrame.src = "./onluyen/kiem_tra_tong_hop.html?v=" + Date.now();
    }

    // Khi m·ªü b√†i: m·∫∑c ƒë·ªãnh KH√îNG cho tho√°t.
    setPretestClosable(false);
    if(elPretestModal){
      elPretestModal.style.display = "block";
      elPretestModal.setAttribute("aria-hidden","false");
    }
  }

function closePretestModal(){
    if(elPretestModal){
      elPretestModal.style.display = 'none';
      elPretestModal.setAttribute('aria-hidden','true');
    }
    if(elPretestFrame) elPretestFrame.src = 'about:blank';

    // Reset tr·∫°ng th√°i ƒë√≥ng
    setPretestClosable(false);
  }

  if(elPretestBtn) elPretestBtn.addEventListener('click', openPretestModal);
  if(elPractice) elPractice.addEventListener('click', openPracticeModal);

  // Ch·ªâ ƒë√≥ng khi ƒë∆∞·ª£c ph√©p (ƒëang "n·∫°p b√†i m·ªõi" theo y√™u c·∫ßu)
  if(elPretestClose) elPretestClose.addEventListener('click', ()=>{ if(__pretestCanClose) closePretestModal(); });
  if(elPretestBackdrop) elPretestBackdrop.addEventListener('click', ()=>{ if(__pretestCanClose) closePretestModal(); });

  // Nh·∫≠n th√¥ng b√°o t·ª´ trang √¥n luy·ªán (iframe)
  // - PASS: m·ªü kh√≥a ngay, nh∆∞ng KH√îNG t·ª± ƒë√≥ng modal (HS t·ª± b·∫•m n√∫t "L√†m code" ƒë·ªÉ quay l·∫°i)
  // - GO_CODE: HS b·∫•m "L√†m code" => ƒë√≥ng modal v√† focus editor
  window.addEventListener('message', (e)=>{
    const d = e && e.data;
    if(!d || !d.type) return;
    if(d.scope && String(d.scope) !== String(_scope)) return;

    // Trang b√†i ki·ªÉm tra trong iframe ƒëi·ªÅu khi·ªÉn vi·ªác hi·ªán/·∫©n n√∫t X tho√°t.
    if(d.type === 'py10_pretest_can_close'){
      setPretestClosable(!!d.canClose);
      return;
    }

    if(d.type === 'py10_pretest_pass'){
      applyPretestGate();

      // Kh√¥ng auto close n·ªØa (ƒë·ªÉ HS ch·ªß ƒë·ªông). Ch·ªâ c·∫≠p nh·∫≠t d√≤ng m√¥ t·∫£ cho r√µ.
      try{
        const info = gateInfoForGroup(currentGroupId());
        if(!info.locked && elPretestSub){
          elPretestSub.textContent = '‚úÖ ƒê·∫°t y√™u c·∫ßu. B·∫•m n√∫t ‚ÄúL√ÄM CODE‚Äù trong b√†i ki·ªÉm tra ƒë·ªÉ quay l·∫°i ph·∫ßn code.';
        }
      }catch(e){}
      return;
    }

    if(d.type === 'py10_pretest_go_code'){
      try{ applyPretestGate(); }catch(e){}
      closePretestModal();
      try{ if(editor && typeof editor.focus === 'function') editor.focus(); }catch(e){}
      return;
    }
  });

  // Tr∆∞·ªùng h·ª£p HS l√†m √¥n luy·ªán ·ªü tab kh√°c
  window.addEventListener('storage', (e)=>{
    if(!e || !e.key) return;
    if(e.key.startsWith(`py10:pretest:${_scope}:`)){
      setTimeout(()=>{ applyPretestGate(); }, 60);
    }
  });

  let pyodide = null;
  const state = {
    currentId: PROBLEMS[0].id,
    hintClicks: 0,
    maxHint: 5,
    runCount: 0,
    lastRunHadError: false,
    lastRunPassed: false,
    lastErrText: "",
    failStreak: 0,
    liveTimer: null,
    lastSelectableId: PROBLEMS[0].id,
  };

  // =======================
  // Helpers
  // =======================
  function escapeHTML(s){ return (s??"").toString().replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;"); }

  // =======================
  // Friendly error formatting (Pyodide / runtime)
  // - Gi√∫p HS th·∫•y ƒë√∫ng "l·ªói c·ªßa m√¨nh" (t√™n l·ªói + d√≤ng) thay v√¨ traceback n·ªôi b·ªô _pyodide.
  // - Gi·ªØ UI c≈©: ch·ªâ thay n·ªôi dung box Output/L·ªói.
  // =======================
  function _lastNonEmptyLine(s){
    const lines = String(s||"").replace(/\r\n/g,"\n").split("\n");
    for(let i=lines.length-1;i>=0;i--){
      const t = (lines[i]||"").trim();
      if(t) return t;
    }
    return "";
  }
  function _extractPyLine(trace){
    const lines = String(trace||"").replace(/\r\n/g,"\n").split("\n");
    // ∆Øu ti√™n line thu·ªôc code h·ªçc sinh (compile v·ªõi <user_code>) n·∫øu c√≥
    for(let i=lines.length-1;i>=0;i--){
      const m = lines[i].match(/File\s+"<user_code>",\s*line\s*(\d+)/i);
      if(m) return parseInt(m[1],10);
    }
    // Fallback: line trong <exec>
    for(let i=lines.length-1;i>=0;i--){
      const m = lines[i].match(/File\s+"<exec>",\s*line\s*(\d+)/i);
      if(m) return parseInt(m[1],10);
    }
    // Fallback cu·ªëi: b·∫•t k·ª≥ "line N"
    for(let i=lines.length-1;i>=0;i--){
      const m = lines[i].match(/line\s+(\d+)/i);
      if(m) return parseInt(m[1],10);
    }
    return null;
  }
  function _extractPyTypeAndMsg(trace){
    const lines = String(trace||"").replace(/\r\n/g,"\n").split("\n").map(x=>(x||"").trim()).filter(Boolean);
    // T√¨m t·ª´ d∆∞·ªõi l√™n: b·ªè qua JS stack "at ..." ƒë·ªÉ kh√¥ng b·ªã d√≠nh "at wrapper"
    for(let i=lines.length-1;i>=0;i--){
      const s = lines[i];
      if(/^at\s+\w+/i.test(s)) continue;
      const m = s.match(/^([A-Za-z_][A-Za-z0-9_]*)(?::\s*(.*))?$/);
      if(!m) continue;
      const type = m[1]||"";
      const msg  = (m[2]||"").trim();
      const ok = /(Error|Exception)$/.test(type) || ["SyntaxError","IndentationError","TabError","SystemExit","KeyboardInterrupt"].includes(type);
      if(ok) return { type, msg };
    }
    const last = _lastNonEmptyLine(trace);
    return { type:"", msg:last };
  }
  function _codeLineAt(code, ln1){
    if(!ln1) return "";
    const lines = String(code||"").split(/\n/);
    const idx = ln1-1;
    if(idx<0 || idx>=lines.length) return "";
    return lines[idx];
  }
  function _viHintForPyError(type, msg, lineCode=""){
    const t = String(type||"");
    const m = String(msg||"");
    const line = String(lineCode||"");

    // Ch·ªâ g·ª£i √Ω khi ch·∫Øc ch·∫Øn; ∆∞u ti√™n ng·∫Øn g·ªçn.
    if(t === "SyntaxError" || t === "IndentationError" || t === "TabError"){
      if(/^\s*elseif\b/i.test(line) || /^\s*else\s+if\b/i.test(line)){
        return "Python kh√¥ng c√≥ `elseif` ‚Üí d√πng `elif`.";
      }
      if(/\&\&|\|\|/.test(line)){
        return "Python d√πng `and` / `or` thay cho `&&` / `||`.";
      }
      if(/==="/.test(line) || /!==/.test(line)){
        return "Python d√πng `==` / `!=` (kh√¥ng c√≥ `===` / `!==`).";
      }
      if(/\+\+|--/.test(line)){
        return "Python kh√¥ng c√≥ `++/--` ‚Üí d√πng `+= 1` ho·∫∑c `-= 1`.";
      }
      if(/^\s*{/.test(line) || /}\s*$/.test(line)){
        return "Python kh√¥ng d√πng `{}` t·∫°o kh·ªëi ‚Üí d√πng `:` v√† th·ª•t l·ªÅ.";
      }
      if(/EOL while scanning string literal/i.test(m)){
        return "Thi·∫øu d·∫•u nh√°y k·∫øt th√∫c chu·ªói.";
      }
      if(/unexpected EOF/i.test(m)){
        return "Thi·∫øu d·∫•u ƒë√≥ng ngo·∫∑c `)` / `]` / `}` ho·∫∑c thi·∫øu ph·∫ßn c√≤n l·∫°i.";
      }
      if(/expected ':'/i.test(m)){
        return "Thi·∫øu d·∫•u `:` sau `if/elif/else/for/while/def`.";
      }
      if(t === "IndentationError" || t === "TabError"){
        return "Sai th·ª•t l·ªÅ: sau `:` ph·∫£i th·ª•t v√†o 4 spaces; ƒë·ª´ng tr·ªôn tab/space.";
      }
      return "SyntaxError: ki·ªÉm tra d·∫•u `:`, ngo·∫∑c, v√† t·ª´ kh√≥a ·ªü d√≤ng b√°o l·ªói.";
    }

    if(t === "NameError"){
      const m1 = m.match(/name '([^']+)' is not defined/);
      return m1 ? `Ch∆∞a ƒë·ªãnh nghƒ©a: \`${m1[1]}\` (g√µ sai t√™n ho·∫∑c qu√™n g√°n).` : "D√πng t√™n ch∆∞a ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a (qu√™n g√°n / sai ch√≠nh t·∫£).";
    }
    if(t === "ZeroDivisionError") return "Chia cho 0: ki·ªÉm tra m·∫´u s·ªë tr∆∞·ªõc khi chia.";
    if(t === "EOFError") return "Thi·∫øu input: ch∆∞∆°ng tr√¨nh g·ªçi `input()` nhi·ªÅu h∆°n s·ªë d√≤ng b·∫°n nh·∫≠p.";
    if(t === "ValueError") return "Sai ƒë·ªãnh d·∫°ng input khi √©p ki·ªÉu (vd: `int(input())`).";
    if(t === "TypeError"){
      if(/can only concatenate str/i.test(m)) return "N·ªëi chu·ªói v·ªõi s·ªë: d√πng `str(...)` ho·∫∑c f-string.";
      if(/unsupported operand type/i.test(m)) return "Sai ki·ªÉu khi + - * /: ki·ªÉm tra/√©p ki·ªÉu tr∆∞·ªõc khi t√≠nh.";
      return "TypeError: ki·ªÉm tra ki·ªÉu d·ªØ li·ªáu v√† c√°ch g·ªçi h√†m.";
    }
    if(t === "IndexError") return "Index ngo√†i ph·∫°m vi: ki·ªÉm tra `len(...)` tr∆∞·ªõc khi truy c·∫≠p.";
    if(t === "KeyError") return "Key kh√¥ng t·ªìn t·∫°i trong dict: ki·ªÉm tra key tr∆∞·ªõc khi d√πng.";
    if(t === "AttributeError") return "Thu·ªôc t√≠nh/h√†m kh√¥ng t·ªìn t·∫°i tr√™n ƒë·ªëi t∆∞·ª£ng.";
    return "";
  }
  function formatSystemError(e, code){
    const raw = (e && (e.stack || e.message)) ? String(e.stack || e.message) : String(e);
    const s = raw.replace(/\r\n/g,"\n");

    // N·∫øu c√≥ traceback Python (th∆∞·ªùng b·ªã b·ªçc b·ªüi _pyodide), c·ªë g·∫Øng t√°ch l·ªói th·∫≠t.
    const hasTrace = /Traceback\s*\(most recent call last\)/i.test(s)
      || /PythonError/i.test(s)
      || /File\s+"<exec>"/i.test(s)
      || /File\s+"<user_code>"/i.test(s);
    if(hasTrace){
      const ln = _extractPyLine(s);
      const { type, msg } = _extractPyTypeAndMsg(s);
      const lineCode = ln ? _codeLineAt(code, ln) : "";
      const hint = _viHintForPyError(type, msg, lineCode);

      const parts = [];
      parts.push(`<span class="x">‚ùå L·ªói:</span> <b>${escapeHTML(type||"L·ªói")}</b>${msg?`: ${escapeHTML(msg)}`:""}`);
      if(ln) parts.push(`<span class="muted">D√≤ng ${ln}${lineCode?`: <code>${escapeHTML(lineCode.trim())}</code>`:""}</span>`);
      if(hint) parts.push(`<span class="hint">üí° G·ª£i √Ω:</span> ${escapeHTML(hint)}`);
      parts.push(`<details style="margin-top:8px"><summary class="muted">Chi ti·∫øt k·ªπ thu·∫≠t</summary><pre style="white-space:pre-wrap; margin:8px 0 0">${escapeHTML(s)}</pre></details>`);
      return parts.join("\n");
    }

    // Kh√¥ng c√≥ traceback -> hi·ªÉn th·ªã nh∆∞ c≈© nh∆∞ng v·∫´n c√≥ chi ti·∫øt.
    return `<span class="x">‚ùå L·ªói h·ªá th·ªëng:</span>\n${escapeHTML(e?.message || String(e))}`;
  }
  function setOutHTML(html){ elOut.innerHTML = html; }
  function setPill(text, kind){ elPill.textContent=text; elPill.className="pill"+(kind?(" "+kind):""); }
  function currentProblem(){ return PROBLEMS.find(p=>p.id===state.currentId); }

  // T√¨m b√†i k·∫ø ti·∫øp (ƒë√£ ƒë∆∞·ª£c m·ªü kh√≥a) theo th·ª© t·ª± danh s√°ch PROBLEMS.
  function findNextUnlockedId(){
    const idx = PROBLEMS.findIndex(p => p.id === state.currentId);
    const progress = loadProgress();
    for(let i = (idx < 0 ? 0 : idx + 1); i < PROBLEMS.length; i++){
      const id = PROBLEMS[i].id;
      if(isUnlockedById(id, progress)) return id;
    }
    return null;
  }

  function normalizeOutput(out){
    out=(out??"").replace(/\r\n/g,"\n");
    out=out.split("\n").map(l=>l.trimEnd()).join("\n");
    out=out.replace(/\n+$/g,"\n");
    return out;
  }
  function simplifyText(s){
    s=(s??"").toString().toLowerCase().trim();
    s=s.normalize("NFD").replace(/[\u0300-\u036f]/g,"");
    s=s.replace(/\s+/g," ");
    return s;
  }
  function tokenize(out){
    const s=normalizeOutput(out).trim();
    if(!s) return [];
    return s.split(/\s+/).filter(Boolean);
  }
  function extractFirstNumber(s){
    const m=(s??"").toString().match(/-?\d+(\.\d+)?/);
    return m?Number(m[0]):null;
  }

  // =======================
  // Monaco setup
  // =======================
  let editor = null;
  function getCode(){ return editor ? editor.getValue() : ""; }
  function setCode(v){ if(editor) editor.setValue(v ?? ""); }
  function getCursorOffset(){
    if(!editor) return 0;
    const pos = editor.getPosition();
    return editor.getModel().getOffsetAt(pos);
  }
  const AC_WORDS = [
    // ===== C∆† B·∫¢N =====
    { label:"print()", insertText:"print(${1:value})", detail:"In k·∫øt qu·∫£ ra m√†n h√¨nh" },
    { label:"input()", insertText:"input()", detail:"Nh·∫≠p d·ªØ li·ªáu (1 d√≤ng)" },
    { label:"int(input())", insertText:"int(input())", detail:"Nh·∫≠p s·ªë nguy√™n" },
    { label:"float(input())", insertText:"float(input())", detail:"Nh·∫≠p s·ªë th·ª±c" },
    { label:"str()", insertText:"str(${1:x})", detail:"√âp ki·ªÉu sang chu·ªói" },
    { label:"len()", insertText:"len(${1:s})", detail:"ƒê·ªô d√†i" },
    { label:"round(x, 2)", insertText:"round(${1:x}, 2)", detail:"L√†m tr√≤n 2 ch·ªØ s·ªë" },
    { label:"range()", insertText:"range(${1:n})", detail:"T·∫°o d√£y s·ªë" },
    { label:"pass", insertText:"pass", detail:"T·∫°m th·ªùi ƒë·ªÉ tr·ªëng kh·ªëi l·ªánh" },

    // ===== C·∫§U TR√öC ƒêI·ªÄU KI·ªÜN =====
    { label:"if ...:", insertText:"if ${1:condition}:\n    ${2:# TODO}\n", detail:"R·∫Ω nh√°nh if" },
    { label:"if ... else ...", insertText:"if ${1:condition}:\n    ${2:# TODO}\nelse:\n    ${3:# TODO}\n", detail:"If/Else ƒë·∫ßy ƒë·ªß" },
    { label:"elif ...:", insertText:"elif ${1:condition}:\n    ${2:# TODO}\n", detail:"Nh√°nh ph·ª• elif" },

    // ===== V√íNG L·∫∂P =====
    { label:"for i in range(...):", insertText:"for ${1:i} in range(${2:1}, ${3:n}+1):\n    ${4:# TODO}\n", detail:"V√≤ng l·∫∑p for (tƒÉng d·∫ßn)" },
    { label:"for i in range(n):", insertText:"for ${1:i} in range(${2:n}):\n    ${3:# TODO}\n", detail:"V√≤ng l·∫∑p for (0..n-1)" },
    { label:"while ...:", insertText:"while ${1:condition}:\n    ${2:# TODO}\n", detail:"V√≤ng l·∫∑p while" },

    // ===== NH·∫¨P NHI·ªÄU GI√Å TR·ªä (M·∫∏O) =====
    { label:"a = int(input())", insertText:"${1:a} = int(input())\n", detail:"Nh·∫≠p 1 s·ªë (1 d√≤ng)" },
    { label:"a,b = map(int, input().split())", insertText:"${1:a}, ${2:b} = map(int, input().split())\n", detail:"Nh·∫≠p 2 s·ªë tr√™n c√πng 1 d√≤ng" },
  ];

  // =======================
  // Coach logic (gi·ªØ nguy√™n)
  // =======================
  function getCurrentLine(code, cursorPos){
    const left = code.slice(0, cursorPos);
    const lines = left.split("\n");
    return { line: lines.length, text: lines[lines.length-1] };
  }

  function hasDanglingBlock(code){
    const lines=(code||"").replace(/\r\n/g,"\n").split("\n");
    for(let i=0;i<lines.length;i++){
      const line=lines[i];
      const t=line.trim();
      if(!t || t.startsWith("#")) continue;
      const isBlock=/^(if|elif|else|for|while|def|try|except|finally|with)\b/.test(t) && t.endsWith(":");
      if(!isBlock) continue;

      let j=i+1;
      while(j<lines.length && lines[j].trim()==="") j++;
      if(j>=lines.length) return {ok:false,line:i+1,reason:"kh·ªëi l·ªánh b·ªã thi·∫øu n·ªôi dung (thi·∫øu th√¢n kh·ªëi)"};

      const next=lines[j];
      const indentNow=line.match(/^\s*/)[0].length;
      const indentNext=next.match(/^\s*/)[0].length;
      if(indentNext<=indentNow) return {ok:false,line:i+1,reason:"thi·∫øu th·ª•t l·ªÅ (thi·∫øu body sau d·∫•u ':')"};
    }
    return {ok:true};
  }

  function liveCoachHint(code, cursorPos, stdinSample){
    const { line, text } = getCurrentLine(code, cursorPos);
    const t = text.trim();
    const linesAll = (code||"").split("\n");
    const nextLine = (linesAll[line] || "").trim();

    // ===== C·∫£nh b√°o t·ª©c th√¨ cho l·ªói "hay g·∫∑p" (nh·∫•n m·∫°nh ph·∫ßn G·ª¢I √ù KHI G√ï CODE) =====

    // 1) Vi·∫øt nh·∫ßm theo ng√¥n ng·ªØ kh√°c
    if (/^\s*elseif\b/i.test(text) || /^\s*else\s+if\b/i.test(text)) {
      return { level:"C·∫¢NH B√ÅO", message:`‚ùå D√≤ng ${line}: Python kh√¥ng c√≥ "elseif/else if".\nüëâ D√πng: elif ...:` };
    }
    if (/\&\&|\|\|/.test(text)) {
      return { level:"C·∫¢NH B√ÅO", message:`‚ùå D√≤ng ${line}: Python kh√¥ng d√πng && / ||.\nüëâ D√πng: and / or` };
    }
    if (/===|!==/.test(text)) {
      return { level:"C·∫¢NH B√ÅO", message:`‚ùå D√≤ng ${line}: Python kh√¥ng c√≥ === / !==.\nüëâ D√πng: == / !=` };
    }
    if (/^\s*(for|while)\s*\(/i.test(text)) {
      return { level:"NH·∫ÆC NH·∫∏", message:`‚ö†Ô∏è D√≤ng ${line}: for/while trong Python KH√îNG c·∫ßn ngo·∫∑c ().\nüëâ V√≠ d·ª•: for i in range(...):  |  while condition:` };
    }
    if (/[{}]/.test(text)) {
      if (/^\s*{/.test(text) || /}\s*$/.test(text)) {
        return { level:"NH·∫ÆC NH·∫∏", message:`‚ö†Ô∏è D√≤ng ${line}: Python kh√¥ng d√πng { } ƒë·ªÉ t·∫°o kh·ªëi.\nüëâ D√πng d·∫•u ':' v√† th·ª•t l·ªÅ (4 d·∫•u c√°ch).` };
      }
    }
    // print theo ki·ªÉu Python 2
    if (/^\s*print\s+[^(\s]/.test(text) && !/^\s*print\s*\(/.test(text)) {
      return { level:"NH·∫ÆC NH·∫∏", message:`‚ö†Ô∏è D√≤ng ${line}: Python 3 c·∫ßn print(...).\nüëâ V√≠ d·ª•: print("hello")` };
    }

    // 2) L·ªói ph·ªï bi·∫øn: d√πng '=' thay v√¨ '==' trong ƒëi·ªÅu ki·ªán
    if (/^\s*if\b/i.test(text)) {
      // b·∫Øt d·∫°ng: if a = 3:  (nh∆∞ng tr√°nh >= <= != ==)
      const cond = text.replace(/^\s*if\b/i, "");
      if (/[^=!<>]=[^=]/.test(cond)) {
        return { level:"C·∫¢NH B√ÅO", message:`‚ùå D√≤ng ${line}: trong ƒëi·ªÅu ki·ªán if, b·∫°n ƒëang d√πng '=' (g√°n) thay v√¨ '==' (so s√°nh).\nüëâ V√≠ d·ª• ƒë√∫ng: if a == 3:` };
      }
    }

    // 3) else thi·∫øu n·ªôi dung / thi·∫øu th·ª•t l·ªÅ
    if (t === "else:" || t === "else") {
      return { level: "C·∫¢NH B√ÅO", message: `‚ö†Ô∏è D√≤ng ${line}: nh√°nh else ch∆∞a c√≥ n·ªôi dung.\nüëâ Sau "else:" b·∫°n ph·∫£i vi·∫øt l·ªánh v√† TH·ª§T L·ªÄ (4 d·∫•u c√°ch).` };
    }
    if (/^\s*else\s*:\s*$/.test(text) && nextLine && !/^\s+/.test(linesAll[line] || "")) {
      return { level:"C·∫¢NH B√ÅO", message:`‚ö†Ô∏è D√≤ng ${line}: sau else: d√≤ng d∆∞·ªõi ch∆∞a th·ª•t l·ªÅ.\nüëâ H√£y th·ª•t v√†o 4 d·∫•u c√°ch v√† vi·∫øt l·ªánh.` };
    }

    // 4) Thi·∫øu d·∫•u ':' cu·ªëi d√≤ng
    if (t.startsWith("if ") && !t.endsWith(":")) {
      return { level: "NH·∫ÆC NH·∫∏", message: `‚ö†Ô∏è D√≤ng ${line}: c√¢u l·ªánh if ƒëang thi·∫øu d·∫•u ":" ·ªü cu·ªëi.\nüëâ V√≠ d·ª•: if ... :` };
    }
    if ((t.startsWith("for ") || t.startsWith("while ") || t.startsWith("elif ")) && !t.endsWith(":")) {
      return { level:"NH·∫ÆC NH·∫∏", message:`‚ö†Ô∏è D√≤ng ${line}: d√≤ng n√†y ƒëang thi·∫øu d·∫•u ":" ·ªü cu·ªëi.\nüëâ Nh·ªõ th√™m ":" r·ªìi m·ªõi vi·∫øt ph·∫ßn th·ª•t l·ªÅ.` };
    }

    // 5) Thi·∫øu input so v·ªõi s·ªë l·∫ßn input() trong code (khi ƒëang ch·∫°y th·ª≠ v·ªõi √¥ Input)
    try{
      const need = _countInputCalls(code);
      const have = _countNonEmptyLines(stdinSample);
      if(need >= 2 && have >= 0 && have < need){
        return { level:"NH·∫ÆC NH·∫∏", message:`‚ö†Ô∏è Code c√≥ kho·∫£ng ${need} l·∫ßn input(), nh∆∞ng √¥ Input ch·ªâ c√≥ kho·∫£ng ${have} d√≤ng.\nüëâ Khi b·∫•m Ch·∫°y th·ª≠/Test c√≥ th·ªÉ b·ªã EOFError. H√£y nh·∫≠p ƒë·ªß d·ªØ li·ªáu.` };
      }
    }catch(e){}

    // 6) C·∫£nh b√°o ngo·∫∑c/nh√°y ch∆∞a ƒë√≥ng (r·∫•t hay g√¢y SyntaxError)
    const unclosed = _v7_scanUnclosedDelimiter(code, line);
    if(unclosed){
      if(unclosed.kind === "quote"){
        return { level:"C·∫¢NH B√ÅO", message:`‚ùå B·∫°n ƒëang m·ªü d·∫•u nh√°y nh∆∞ng ch∆∞a ƒë√≥ng (b·∫Øt ƒë·∫ßu ·ªü d√≤ng ${unclosed.openLine}).\nüëâ ƒê√≥ng d·∫•u nh√°y cho chu·ªói tr∆∞·ªõc khi xu·ªëng d√≤ng.` };
      }
      if(unclosed.kind === "bracket"){
        return { level:"NH·∫ÆC NH·∫∏", message:`‚ö†Ô∏è C√≥ v·∫ª b·∫°n m·ªü '${unclosed.open}' ·ªü d√≤ng ${unclosed.openLine} nh∆∞ng ch∆∞a ƒë√≥ng '${unclosed.close}'.\nüëâ Ki·ªÉm tra l·∫°i ngo·∫∑c (), [], {}.` };
      }
    }

    // 7) int(input()) nh∆∞ng d·ªØ li·ªáu m·∫´u kh√¥ng ph·∫£i s·ªë
    if (/int\s*\(\s*input\s*\(/.test(code)) {
      const sample = (stdinSample || "").trim().split("\n")[0] || "";
      if (sample && isNaN(Number(sample))) {
        return { level: "C·∫¢NH B√ÅO", message: `‚ùå B·∫°n ƒëang d√πng int(input()) nh∆∞ng d·ªØ li·ªáu m·∫´u KH√îNG ph·∫£i s·ªë.\nüëâ C√°ch s·ª≠a:\n- Nh·∫≠p s·ªë (v√≠ d·ª• 10)\n- Ho·∫∑c b·ªè int() n·∫øu b·∫°n c·∫ßn nh·∫≠p ch·ªØ` };
      }
    }

    // 8) Check c·∫•u tr√∫c: sau ':' ph·∫£i c√≥ th√¢n kh·ªëi
    const dangling = hasDanglingBlock(code);
    if (!dangling.ok) {
      return { level:"C·∫¢NH B√ÅO", message:`‚ö†Ô∏è B·∫°n ƒëang thi·∫øu th√¢n kh·ªëi sau d·∫•u ':' (kho·∫£ng d√≤ng ${dangling.line}).\nüëâ C√°ch s·ª≠a: th√™m 1 d√≤ng th·ª•t l·ªÅ b√™n d∆∞·ªõi (4 d·∫•u c√°ch) v√† vi·∫øt l·ªánh.` };
    }
    return null;
  }


    function analyzeProgress(problem, code){
    const c=code||"";
    const req = (problem && problem.req) ? problem.req : null;

    const hasInput=/\binput\s*\(/.test(c);
    const hasPrint=/\bprint\s*\(/.test(c);
    const hasIf=/\bif\b/.test(c);
    const hasLoop=/\bfor\b|\bwhile\b/.test(c);
    const hasMath=/\bint\s*\(|\bfloat\s*\(|%|\/\/|\brange\s*\(/.test(c) || /[\+\-\*\/]/.test(c);

    const dangling=hasDanglingBlock(c);

    let checks = [];

    // N·∫øu ƒë·ªÅ c√≥ "req" ‚Üí checklist b√°m s√°t ƒë·ªÅ (ƒë·ª° b·ªã th·ª´a m·ª•c khi b√†i kh√¥ng c·∫ßn input/if/loop)
    if(req){
      if(req.input) checks.push({key:"input", label:"ƒê√£ ƒë·ªçc input", ok:hasInput});
      if(req.math)  checks.push({key:"math",  label:"C√≥ x·ª≠ l√Ω/t√≠nh to√°n", ok:hasMath});
      if(req.if)    checks.push({key:"if",    label:"C√≥ r·∫Ω nh√°nh if", ok:hasIf});
      if(req.loop)  checks.push({key:"loop",  label:"C√≥ v√≤ng l·∫∑p", ok:hasLoop});
      if(req.print !== false) checks.push({key:"print", label:"ƒê√£ in k·∫øt qu·∫£", ok:hasPrint});

      if(!checks.length){
        checks = [{key:"print", label:"ƒê√£ in k·∫øt qu·∫£", ok:hasPrint}];
      }
    }else{
      // Fallback chung cho b√†i GV giao / b√†i kh√¥ng c√≥ req
      checks = [
        {key:"input", label:"ƒê√£ ƒë·ªçc input", ok:hasInput},
        {key:"parse", label:"ƒê√£ √©p ki·ªÉu/x·ª≠ l√Ω d·ªØ li·ªáu", ok:hasMath},
        {key:"structure", label:"ƒê√£ d√πng if/for/while", ok:(hasIf||hasLoop)},
        {key:"print", label:"ƒê√£ in k·∫øt qu·∫£", ok:hasPrint},
      ];
    }

    let next="";
    if(!dangling.ok){
      next=`‚ö†Ô∏è ∆Øu ti√™n s·ª≠a c·∫•u tr√∫c: thi·∫øu th√¢n kh·ªëi sau ':' (d√≤ng ${dangling.line}).\nüëâ Sau d√≤ng c√≥ ':' ph·∫£i c√≥ d√≤ng th·ª•t l·ªÅ b√™n d∆∞·ªõi (4 d·∫•u c√°ch).`;
      return {checks,next};
    }

    const live = liveCoachHint(c, getCursorOffset(), elStdin.value);
    if(live) return {checks, next:`üß† ${live.level}\n${live.message}`};

    const firstNo = checks.find(x=>!x.ok);

    const map={
      input:"B∆∞·ªõc ti·∫øp theo: ƒë·ªçc ƒë·ªß d·ªØ li·ªáu theo ƒë·ªÅ (ƒë√∫ng s·ªë d√≤ng/ƒë√∫ng th·ª© t·ª±).",
      math:"B∆∞·ªõc ti·∫øp theo: x·ª≠ l√Ω d·ªØ li·ªáu / t√≠nh to√°n theo y√™u c·∫ßu.",
      if:"B∆∞·ªõc ti·∫øp theo: chia tr∆∞·ªùng h·ª£p ƒë·ªÉ x·ª≠ l√Ω (r·∫Ω nh√°nh).",
      loop:"B∆∞·ªõc ti·∫øp theo: d√πng v√≤ng l·∫∑p theo y√™u c·∫ßu ƒë·ªÅ b√†i.",
      print:"B∆∞·ªõc ti·∫øp theo: in k·∫øt qu·∫£ cu·ªëi c√πng (ƒë√∫ng ƒë·ªãnh d·∫°ng).",
      parse:"B∆∞·ªõc ti·∫øp theo: chuy·ªÉn d·ªØ li·ªáu sang d·∫°ng s·ªë n·∫øu ƒë·ªÅ y√™u c·∫ßu.",
      structure:"B∆∞·ªõc ti·∫øp theo: ch·ªçn c·∫•u tr√∫c ph√π h·ª£p (r·∫Ω nh√°nh / v√≤ng l·∫∑p / ...).",
    };

    // "Khung nhanh" d·∫°ng d√†n √Ω (KH√îNG ƒë∆∞a code m·∫´u)
    const frameMap = {
      input: `Khung g·ª£i √Ω:\n- ƒê·ªçc ƒë·ªß d·ªØ li·ªáu theo ƒë√∫ng s·ªë d√≤ng c·ªßa ƒë·ªÅ.\n- N·∫øu ƒë·ªÅ y√™u c·∫ßu s·ªë: chuy·ªÉn d·ªØ li·ªáu sang s·ªë tr∆∞·ªõc khi t√≠nh.`,
      math:  `Khung g·ª£i √Ω:\n- T·∫°o bi·∫øn k·∫øt qu·∫£.\n- T√≠nh theo c√¥ng th·ª©c/ƒëi·ªÅu ki·ªán ƒë·ªÅ b√†i.`,
      if:    `Khung g·ª£i √Ω:\n- X√°c ƒë·ªãnh c√°c tr∆∞·ªùng h·ª£p.\n- M·ªói tr∆∞·ªùng h·ª£p c·∫≠p nh·∫≠t k·∫øt qu·∫£.\n- Cu·ªëi c√πng in ra 1 k·∫øt qu·∫£ theo y√™u c·∫ßu.`,
      loop:  `Khung g·ª£i √Ω:\n- X√°c ƒë·ªãnh ph·∫°m vi l·∫∑p.\n- M·ªói v√≤ng l·∫∑p c·∫≠p nh·∫≠t t·ªïng/ƒë·∫øm/k·∫øt qu·∫£.\n- K·∫øt th√∫c th√¨ in ra.`,
      print: `Khung g·ª£i √Ω:\n- In ƒë√∫ng ƒë·ªãnh d·∫°ng (ƒë√∫ng ch·ªØ, ƒë√∫ng d·∫•u c√°ch, ƒë√∫ng xu·ªëng d√≤ng).`,
      parse: `Khung g·ª£i √Ω:\n- N·∫øu ƒë·ªÅ l√† s·ªë: nh·ªõ chuy·ªÉn d·ªØ li·ªáu sang s·ªë tr∆∞·ªõc khi t√≠nh to√°n.`,
      structure: `Khung g·ª£i √Ω:\n- Ch·ªçn 1 h∆∞·ªõng: r·∫Ω nh√°nh / v√≤ng l·∫∑p / t√≠nh c√¥ng th·ª©c.\n- Vi·∫øt t·ª´ng b∆∞·ªõc nh·ªè, ki·ªÉm tra d·∫ßn b·∫±ng Ch·∫°y th·ª≠.`,
    };

    const hasCast = /\bint\s*\(|\bfloat\s*\(/.test(c) || /\bmap\s*\(\s*int\b/.test(c);

    if(firstNo){
      next = (map[firstNo.key] || "B∆∞·ªõc ti·∫øp theo: l√†m theo t·ª´ng b∆∞·ªõc c·ªßa ƒë·ªÅ.");

      const sn = frameMap[firstNo.key] || "";
      if(sn){
        next += "\n\n" + sn;
      }

      // Nh·∫•n m·∫°nh l·ªói hay g·∫∑p: qu√™n √©p ki·ªÉu s·ªë
      if(req && req.math && req.input && hasInput && !hasCast){
        next += "\n\n‚ö†Ô∏è Nh·∫Øc nh·∫π: b·∫°n ƒëang ƒë·ªçc d·ªØ li·ªáu nh∆∞ng ch∆∞a chuy·ªÉn sang ki·ªÉu s·ªë."+
                "\nüëâ N·∫øu ƒë·ªÅ y√™u c·∫ßu s·ªë, h√£y chuy·ªÉn d·ªØ li·ªáu sang s·ªë nguy√™n ho·∫∑c s·ªë th·ª±c tr∆∞·ªõc khi t√≠nh.";
      }

      next += "\n\nüëâ M·∫πo: nh·∫•n Ctrl+Space ƒë·ªÉ hi·ªán g·ª£i √Ω code trong editor.";
      return {checks,next};
    }

    next = (state.lastRunPassed
              ? "‚úÖ ƒê·ªß b∆∞·ªõc c∆° b·∫£n. N·∫øu FAIL: ki·ªÉm tra ƒëi·ªÅu ki·ªán bi√™n + ƒë·ªãnh d·∫°ng output."
              : "‚úÖ ƒê·ªß b∆∞·ªõc c∆° b·∫£n. H√£y b·∫•m Test ƒë·ªÉ ki·ªÉm tra test case.");
    return {checks,next};
  }

  function updateCoach(){
    const p=currentProblem();
    const {checks,next}=analyzeProgress(p, getCode());
    elCoachChecklist.innerHTML = checks.map(c => `<li>${c.ok?`<span class="ok">‚úÖ</span>`:`<span class="no">‚¨ú</span>`} ${escapeHTML(c.label)}</li>`).join("");
    elCoachNext.textContent = next;
  }

  function debounceCoach(ms=200){
    if(state.liveTimer) clearTimeout(state.liveTimer);
    state.liveTimer=setTimeout(updateCoach, ms);
  }

  // =======================
  // Error ti·∫øng Vi·ªát
  // =======================
  // T√™n "file" m√† Python d√πng trong traceback khi ch·∫°y code ng∆∞·ªùi h·ªçc.
// (B·∫£n m·ªõi d√πng "main.py" ƒë·ªÉ gi·ªëng ch·∫°y file th·∫≠t; v·∫´n gi·ªØ "<user_code>" ƒë·ªÉ t∆∞∆°ng th√≠ch c≈©.)
  const USER_CODE_FILENAMES = ["main.py", "<user_code>"];

  function _normNL(s){ return (s ?? "").toString().replace(/\r\n/g,"\n"); }
  function _escapeRegExp(s){ return String(s).replace(/[.*+?^${}()|[\]\\]/g,'\\$&'); }

  function extractLineNoFromTrace(stderr){
    const lines=_normNL(stderr).split("\n");

    // 1) ∆Øu ti√™n frame thu·ªôc code ng∆∞·ªùi h·ªçc
    for(const tag of USER_CODE_FILENAMES){
      const re = new RegExp('File\\s+\"'+_escapeRegExp(tag)+'\",\\s*line\\s*(\\d+)', 'i');
      for(let i=lines.length-1;i>=0;i--){
        const m = lines[i].match(re);
        if(m) return parseInt(m[1],10);
      }
    }

    // 2) Fallback: frame File "...", line N b·∫•t k·ª≥
    for(let i=lines.length-1;i>=0;i--){
      const m = lines[i].match(/File\s+\".*?\",\s*line\s*(\d+)/i);
      if(m) return parseInt(m[1],10);
    }

    // 3) Cu·ªëi c√πng: t√¨m "line N" nh∆∞ng tr√°nh b·ªã d√≠nh "...detected at line N"
    for(let i=lines.length-1;i>=0;i--){
      if(/detected at line/i.test(lines[i])) continue;
      const m = lines[i].match(/\bline\s+(\d+)\b/i);
      if(m) return parseInt(m[1],10);
    }
    return null;
  }

function extractErrTypeMsg(stderr){
    const lines=_normNL(stderr).split("\n").map(x=>String(x||"").trim()).filter(Boolean);
    // T√¨m t·ª´ d∆∞·ªõi l√™n ƒë·ªÉ l·∫•y ƒë√∫ng exception cu·ªëi c√πng, b·ªè qua JS stack (n·∫øu c√≥)
    for(let i=lines.length-1;i>=0;i--){
      const s = lines[i];
      if(!s) continue;
      if(/^at\s+\w+/i.test(s)) continue; // JS stack
      if(/^file\s+"https?:\/\//i.test(s)) continue;

      // d·∫°ng: NameError: ...  | SyntaxError: ... | KeyboardInterrupt
      const m = s.match(/^([A-Za-z_][A-Za-z0-9_]*)(?::\s*(.*))?$/);
      if(!m) continue;
      const type = m[1] || "";
      const msg  = (m[2] || "").trim();

      const looksLikePyErr = /(Error|Exception)$/.test(type)
        || ["SyntaxError","IndentationError","TabError","SystemExit","KeyboardInterrupt"].includes(type);
      if(looksLikePyErr) return {type, msg};
    }
    const last = lines.length ? lines[lines.length-1] : "";
    return {type:"Error", msg:last};
  }

  function classifyPythonError(stderr){
    const {type} = extractErrTypeMsg(stderr);
    return type || "Other";
  }

  function _getCodeLine(code, ln1){
    const arr = (code||"").toString().split("\n");
    const i = (ln1||0)-1;
    if(i<0 || i>=arr.length) return "";
    return arr[i];
  }

  function _countInputCalls(code){
    // ƒë·∫øm th√¥ (ƒë·ªß t·ªët ƒë·ªÉ g·ª£i √Ω)
    const s = (code||"").toString().replace(/#.*$/gm,"");
    const m = s.match(/\binput\s*\(/g);
    return m ? m.length : 0;
  }
  function _countNonEmptyLines(s){
    return _normNL(s).split("\n").filter(x=>String(x||"").trim()!=="").length;
  }

  // L√†m s·∫°ch: b·ªè c√°c d√≤ng JS stack "at ..." n·∫øu err l·∫´n c·∫£ stack JS.
  function _stripJsStack(s){
    return _normNL(s)
      .split("\n")
      .filter(line => !/^\s*at\s+\w+/i.test(line.trim()))
      .join("\n")
      .trim();
  }
  // Gi·∫£i th√≠ch l·ªói theo ki·ªÉu "Python b√¨nh th∆∞·ªùng" + h∆∞·ªõng d·∫´n s·ª≠a chi ti·∫øt.
  // - Lu√¥n b√°m v√†o type/msg Python tr·∫£ ra (ch√≠nh x√°c)
  // - G·ª£i √Ω s·ª≠a: theo m·∫´u l·ªói ph·ªï bi·∫øn + c√≥ th·ªÉ b√°m theo b√†i ƒëang l√†m
  function _v7_escapeRegExp(s){ return String(s).replace(/[.*+?^${}()|[\]\\]/g,'\\$&'); }
  function _v7_detectedLineFromMsg(msg){
    const m = String(msg||"").match(/detected at line\s+(\d+)/i);
    return m ? parseInt(m[1],10) : null;
  }
  function _v7_parseSyntaxPointerFromTrace(trace){
    const lines = _normNL(trace).split("\n");
    // D·∫°ng chu·∫©n do runner in ra:
    //   File "main.py", line N
    //     <code>
    //         ^^^
    for(let i=0;i<lines.length;i++){
      const m = lines[i].match(/File\s+\"(main\.py|<user_code>|<exec>)\",\s*line\s*(\d+)/i);
      if(!m) continue;
      const ln = parseInt(m[2],10);
      const codeLineTrace = (lines[i+1] ?? "");
      const caretLine = (lines[i+2] ?? "");
      if(caretLine.includes("^")){
        const first = caretLine.indexOf("^");
        const last  = caretLine.lastIndexOf("^");
        // Runner lu√¥n in 4 spaces tr∆∞·ªõc d√≤ng code v√† tr∆∞·ªõc caret line
        const col = Math.max(1, first - 3); // -4 + 1
        const endCol = Math.max(col, last - 3);
        return { line: ln, col, endCol, codeLineTrace, caretLine };
      }
    }
    return null;
  }
  function _v7_parseLastUserFrame(trace){
    const lines = _normNL(trace).split("\n");
    for(let i=lines.length-1;i>=0;i--){
      const m = lines[i].match(/File\s+\"(main\.py|<user_code>|<exec>)\",\s*line\s*(\d+)(?:,\s*in\s*([^\n]+))?/i);
      if(!m) continue;
      const ln = parseInt(m[2],10);
      const func = (m[3]||"").trim();
      let codeLineTrace = "";
      if(i+1 < lines.length && /^\s{4}\S/.test(lines[i+1]||"")){
        codeLineTrace = String(lines[i+1]||"").trimEnd();
      }
      return { filename: m[1], line: ln, func, codeLineTrace };
    }
    return null;
  }
  function _v7_tokenAtColumn(line, col){
    const s = String(line||"");
    if(!col || col<1) return "";
    const idx = col-1;
    if(idx<0 || idx>=s.length) return "";
    const isWord = (c)=>/[A-Za-z0-9_]/.test(c);
    let l = idx, r = idx;
    while(l>0 && isWord(s[l-1])) l--;
    while(r<s.length && isWord(s[r])) r++;
    const tok = s.slice(l,r);
    return tok;
  }
  function _v7_prevMeaningfulLine(code, fromLine){
    const arr = _normNL(code||"").split("\n");
    for(let i=Math.min(arr.length, (fromLine||1)-1)-1; i>=0; i--){
      const t = (arr[i]||"").trim();
      if(!t || t.startsWith("#")) continue;
      return { line:i+1, text: arr[i] };
    }
    return null;
  }
  function _v7_scanUnclosedDelimiter(code, uptoLine){
    const lines = _normNL(code||"").split("\n");
    const lim = uptoLine ? Math.min(lines.length, uptoLine) : lines.length;
    const stack = [];
    const closeMap = {"(" : ")", "[" : "]", "{" : "}"};
    const pairOpen = {")":"(", "]":"[", "}":"{"};
    let inStr = null;      // "'" or '"'
    let inTriple = null;   // "'" or '"'
    let esc = false;
    let strLine = 1;

    for(let li=0; li<lim; li++){
      const s = lines[li] || "";
      const lineNo = li+1;
      for(let i=0;i<s.length;i++){
        const ch = s[i];

        if(inTriple){
          const q = inTriple;
          if(ch===q && s[i+1]===q && s[i+2]===q){ inTriple=null; i+=2; continue; }
          continue;
        }
        if(inStr){
          if(esc){ esc=false; continue; }
          if(ch==="\\"){ esc=true; continue; }
          if(ch===inStr){ inStr=null; continue; }
          continue;
        }

        if(ch==="#") break; // comment

        if((ch==="'" || ch==='"') && s[i+1]===ch && s[i+2]===ch){
          inTriple = ch; strLine = lineNo; i+=2; continue;
        }
        if(ch==="'" || ch==='"'){
          inStr = ch; strLine = lineNo; continue;
        }

        if(ch==="(" || ch==="[" || ch==="{"){ stack.push({ch, line: lineNo}); continue; }
        if(ch===")" || ch==="]" || ch==="}"){
          const need = pairOpen[ch];
          if(stack.length && stack[stack.length-1].ch===need) stack.pop();
          continue;
        }
      }
    }

    if(inTriple || inStr){
      return { kind:"quote", q:(inTriple || inStr), openLine: strLine };
    }
    if(stack.length){
      const top = stack[stack.length-1];
      return { kind:"bracket", open: top.ch, close: closeMap[top.ch], openLine: top.line };
    }
    return null;
  }
  function _v7_addColon(line){
    const s = String(line||"");
    const idx = s.indexOf("#");
    if(idx >= 0){
      const head = s.slice(0, idx).replace(/\s+$/,"");
      const tail = s.slice(idx);
      return head + ":" + (tail ? " " + tail.trimStart() : "");
    }
    return s.replace(/\s+$/,"") + ":";
  }
  function _v7_buildContext(code, lineNo, colNo, endCol){
    if(lineNo == null) return "";
    const arr = _normNL(code||"").split("\n");
    const start = Math.max(1, lineNo-2);
    const end = Math.min(arr.length, lineNo+2);
    const w = String(end).length;
    const out = [];
    out.push("\nüìå Code quanh d√≤ng l·ªói (b√°m ƒë√∫ng code c·ªßa b·∫°n):");
    for(let i=start;i<=end;i++){
      const num = String(i).padStart(w," ");
      const mark = (i===lineNo) ? "üëâ" : "  ";
      out.push(`${mark} ${num} | ${arr[i-1] ?? ""}`);
      if(i===lineNo && colNo != null){
        const span = (endCol != null && endCol >= colNo) ? Math.max(1, endCol-colNo+1) : 1;
        const caret = "^".repeat(span);
        out.push(`   ${" ".repeat(w)} | ${" ".repeat(Math.max(0, colNo-1))}${caret} (c·ªôt ${colNo}${(endCol!=null && endCol>colNo)?`-${endCol}`:""})`);
      }
    }
    return out.join("\n");
  }

  function _v7_buildTips(type, msg, cleanTrace, code, stdin, problem, lineNo, colNo, endCol){
    const tips = [];
    const tip = (s)=>{ if(s && tips.length < 3) tips.push(s); };

    const t = String(type||"");
    const m = String(msg||"");
    const ml = m.toLowerCase();
    const lineText = (lineNo!=null) ? _getCodeLine(code, lineNo) : "";
    const lineTrim = String(lineText||"").trim();

    // ========== SyntaxError / IndentationError / TabError ==========
    if(t === "SyntaxError" || t === "IndentationError" || t === "TabError"){

      // 1) elseif / else if
      if(/^elseif\b/i.test(lineTrim) || /^else\s+if\b/i.test(lineTrim)){
        let fixed = lineText;
        if(/^\s*elseif\b/i.test(lineText||"")) fixed = String(lineText||"").replace(/\belseif\b/i, "elif");
        else fixed = String(lineText||"").replace(/^(\s*)else\s+if\b/i, "$1elif");
        tip(`D√≤ng ${lineNo}: Python kh√¥ng c√≥ \`elseif/else if\` ‚Üí d√πng \`elif\`.`);
        tip(`S·ª≠a th√†nh: ${fixed.trim()}`);
        tip("ƒê·∫£m b·∫£o `elif` c√πng m·ª©c th·ª•t l·ªÅ v·ªõi `if`.");
        return tips;
      }

      // 2) D·∫•u : thi·∫øu
      const isBlock = /^(if|elif|else|for|while|def|class|try|except|finally|with)\b/i.test(lineTrim);
      if(ml.includes("expected ':'") || (t==="SyntaxError" && isBlock && !lineTrim.endsWith(":"))){
        tip(`Thi·∫øu d·∫•u \`:\` ·ªü cu·ªëi d√≤ng ${lineNo}.`);
        tip(`S·ª≠a th√†nh: ${_v7_addColon(lineText).trim()}`);
        tip("D√≤ng b√™n d∆∞·ªõi ph·∫£i th·ª•t l·ªÅ (khuy·∫øn ngh·ªã 4 d·∫•u c√°ch).");
        return tips;
      }

      // 3) Thi·∫øu th·ª•t l·ªÅ sau :
      if(t === "IndentationError" && ml.includes("expected an indented block")){
        const mm = m.match(/on line\s+(\d+)/i);
        const baseLine = mm ? parseInt(mm[1],10) : (lineNo!=null ? lineNo-1 : null);
        if(baseLine){
          tip(`Thi·∫øu n·ªôi dung kh·ªëi sau d·∫•u ':' ·ªü d√≤ng ${baseLine}.`);
          tip(`Sau d√≤ng ${baseLine} ph·∫£i c√≥ d√≤ng th·ª•t l·ªÅ (4 d·∫•u c√°ch).`);
          tip("N·∫øu ch∆∞a mu·ªën vi·∫øt g√¨, b·∫°n c√≥ th·ªÉ t·∫°m ƒë·∫∑t `pass` trong kh·ªëi ƒë·ªÉ h·∫øt l·ªói.");
        }else{
          tip("Thi·∫øu n·ªôi dung kh·ªëi sau d·∫•u ':'.");
          tip("Sau if/for/while/def ...: ph·∫£i c√≥ √≠t nh·∫•t 1 d√≤ng th·ª•t l·ªÅ.");
        }
        return tips;
      }

      // 4) Unterminated string
      if(ml.includes("unterminated string literal") || ml.includes("eol while scanning string literal")){
        tip(`Thi·∫øu d·∫•u nh√°y ƒë√≥ng chu·ªói ·ªü d√≤ng ${lineNo}.`);
        // g·ª£i √Ω s√°t theo d√≤ng code
        if(/rstrip\s*\(\s*\"$/.test(String(lineText||"").trimEnd())){
          tip(`B·∫°n ƒëang vi·∫øt \`${lineTrim}\` ‚Üí th∆∞·ªùng ƒë√∫ng s·∫Ω l√†: \`return s.rstrip(\"\\n\")\` ho·∫∑c \`return s.rstrip()\`.`);
          tip("ƒê√≥ng d·∫•u nh√°y `\"` v√† ki·ªÉm tra c√≥ thi·∫øu d·∫•u `)` ·ªü cu·ªëi d√≤ng kh√¥ng.");
        }else{
          tip("Th√™m d·∫•u nh√°y ƒë√≥ng (`\"` ho·∫∑c `'`) tr∆∞·ªõc khi xu·ªëng d√≤ng.");
          tip("N·∫øu mu·ªën chu·ªói nhi·ªÅu d√≤ng: d√πng \"\"\"...\"\"\".");
        }
        return tips;
      }

      // 5) Ngo·∫∑c ch∆∞a ƒë√≥ng / EOF
      if(ml.includes("was never closed") || ml.includes("unexpected eof") || ml.includes("unexpected EOF".toLowerCase())){
        const u = _v7_scanUnclosedDelimiter(code, lineNo || undefined);
        if(u && u.kind === "quote"){
          tip(`Thi·∫øu ƒë√≥ng d·∫•u nh√°y (${u.q}) m·ªü ·ªü d√≤ng ${u.openLine}.`);
          tip("ƒê√≥ng chu·ªói ƒë√∫ng s·ªë d·∫•u nh√°y (1 ho·∫∑c 3) tr∆∞·ªõc khi vi·∫øt ti·∫øp.");
          tip(`Ki·ªÉm tra l·∫°i d√≤ng ${u.openLine} v√† c√°c d√≤ng ngay sau ƒë√≥.`);
        }else if(u && u.kind === "bracket"){
          tip(`Thi·∫øu k√Ω t·ª± ƒë√≥ng \`${u.close}\` cho \`${u.open}\` (m·ªü ·ªü d√≤ng ${u.openLine}).`);
          tip(`Th√™m \`${u.close}\` ƒë√∫ng v·ªã tr√≠ ƒë·ªÉ ƒë√≥ng bi·ªÉu th·ª©c.`);
          tip("Ki·ªÉm tra c√°c c·∫∑p (), [], {} ·ªü c√°c d√≤ng tr∆∞·ªõc.");
        }else{
          tip("Thi·∫øu d·∫•u ƒë√≥ng ngo·∫∑c `)`, `]` ho·∫∑c `}` (ho·∫∑c thi·∫øu ph·∫ßn c√≤n l·∫°i c·ªßa bi·ªÉu th·ª©c).");
          tip("Quay l·∫°i d√≤ng c√≥ d·∫•u ngo·∫∑c m·ªü g·∫ßn nh·∫•t v√† ƒë√≥ng cho ƒë·ªß.");
        }
        return tips;
      }

      // 6) Nh·∫ßm to√°n t·ª≠ ki·ªÉu C/JS
      if(/\&\&/.test(lineText||"")){
        tip(`D√≤ng ${lineNo} d√πng \`&&\` (C/JS). Python d√πng \`and\`.`);
        tip(`S·ª≠a: thay \`&&\` ‚Üí \`and\`.`);
        return tips;
      }
      if(/\|\|/.test(lineText||"")){
        tip(`D√≤ng ${lineNo} d√πng \`||\` (C/JS). Python d√πng \`or\`.`);
        tip(`S·ª≠a: thay \`||\` ‚Üí \`or\`.`);
        return tips;
      }
      if(/==="/.test(lineText||"") || /!==/.test(lineText||"")){
        tip(`D√≤ng ${lineNo} d√πng \`===/!===\` (JS). Python d√πng \`==\` / \`!=\`.`);
        tip("S·ª≠a: `===` ‚Üí `==` v√† `!==` ‚Üí `!=`.");
        return tips;
      }
      if(/\+\+|--/.test(lineText||"")){
        tip(`D√≤ng ${lineNo} d√πng \`++/--\` (C/JS). Python kh√¥ng c√≥.`);
        tip("S·ª≠a: d√πng `i += 1` ho·∫∑c `i -= 1`.");
        return tips;
      }

      // 7) Print ki·ªÉu Python2
      if(ml.includes("missing parentheses in call to 'print'") || (/^print\s+[^(\n]/i.test(lineTrim) && !/^print\s*\(/i.test(lineTrim))){
        tip("B·∫°n ƒëang d√πng `print` ki·ªÉu Python 2. Python 3 ph·∫£i vi·∫øt `print(...)`.");
        if(/^print\s+/i.test(lineTrim)){
          const rest = lineTrim.replace(/^print\s+/i,"");
          tip(`V√≠ d·ª• s·ª≠a: print(${rest})`);
        }
        tip("Gi·ªØ nguy√™n n·ªôi dung c·∫ßn in, ch·ªâ th√™m d·∫•u ngo·∫∑c tr√≤n.");
        return tips;
      }

      // 8) break/continue/return ngo√†i v·ªã tr√≠ h·ª£p l·ªá
      if(ml.includes("'break' outside loop")){
        tip("B·∫°n d√πng `break` ·ªü ngo√†i v√≤ng l·∫∑p. `break` ch·ªâ d√πng trong `for/while`.");
        tip("N·∫øu mu·ªën d·ª´ng ch∆∞∆°ng tr√¨nh: d√πng `return` (trong h√†m) ho·∫∑c c·∫•u tr√∫c ƒëi·ªÅu ki·ªán ph√π h·ª£p.");
        return tips;
      }
      if(ml.includes("'continue' not properly in loop")){
        tip("B·∫°n d√πng `continue` ·ªü ngo√†i v√≤ng l·∫∑p. `continue` ch·ªâ d√πng trong `for/while`.");
        return tips;
      }
      if(ml.includes("'return' outside function")){
        tip("B·∫°n d√πng `return` ·ªü ngo√†i h√†m. `return` ch·ªâ d√πng b√™n trong `def ...:`.");
        tip("N·∫øu ƒëang vi·∫øt ch∆∞∆°ng tr√¨nh tr·ª±c ti·∫øp: thay `return` b·∫±ng `print(...)` ho·∫∑c g√°n bi·∫øn.");
        return tips;
      }

      // 9) IndentationError kh√°c
      if(t === "IndentationError" || t === "TabError"){
        if(ml.includes("unexpected indent")){
          tip(`D√≤ng ${lineNo} ƒëang th·ª•t l·ªÅ nh∆∞ng kh√¥ng n·∫±m trong kh·ªëi n√†o.`);
          tip("X√≥a b·ªõt kho·∫£ng tr·∫Øng ƒë·∫ßu d√≤ng (ho·∫∑c ƒë∆∞a d√≤ng v√†o ƒë√∫ng kh·ªëi if/for/while).");
          return tips;
        }
        if(ml.includes("unindent does not match any outer indentation level")){
          tip("Th·ª•t l·ªÅ kh√¥ng kh·ªõp c·∫•p (unindent).");
          tip("D√πng 4 d·∫•u c√°ch cho m·ªói c·∫•p v√† kh√¥ng tr·ªôn TAB/SPACE.");
          return tips;
        }
        if(ml.includes("inconsistent use of tabs and spaces")){
          tip("B·∫°n ƒëang tr·ªôn TAB v√† SPACE.");
          tip("H√£y chuy·ªÉn to√†n b·ªô th·ª•t l·ªÅ sang SPACE (4 d·∫•u c√°ch).");
          return tips;
        }
        tip("Sai th·ª•t l·ªÅ: sau d√≤ng c√≥ ':' ph·∫£i th·ª•t v√†o v√† c√°c d√≤ng trong c√πng kh·ªëi ph·∫£i th·∫≥ng h√†ng.");
        return tips;
      }

      // Fallback cho SyntaxError
      const tok = (colNo!=null && lineText) ? _v7_tokenAtColumn(lineText, colNo) : "";
      if(tok){
        tip(`Sai c√∫ ph√°p g·∫ßn \`${tok}\` ·ªü d√≤ng ${lineNo}${colNo!=null?`, c·ªôt ${colNo}`:""}.`);
      }else if(lineNo!=null){
        tip(`Sai c√∫ ph√°p t·∫°i d√≤ng ${lineNo}${colNo!=null?`, c·ªôt ${colNo}`:""}.`);
      }else{
        tip("Sai c√∫ ph√°p (SyntaxError).");
      }
      tip("Xem d·∫•u `^` trong traceback: ƒë√≥ l√† v·ªã tr√≠ k√Ω t·ª± g√¢y l·ªói.");
      return tips;
    }

    // ========== EOFError ==========
    if(t === "EOFError"){
      const need = _countInputCalls(code);
      const have = _countNonEmptyLines(stdin);
      const miss = Math.max(0, (need||0) - (have||0));
      tip("Ch∆∞∆°ng tr√¨nh g·ªçi `input()` nh∆∞ng √¥ Input ƒë√£ h·∫øt d·ªØ li·ªáu.");
      if(need){
        tip(`Code c√≥ ~${need} l·∫ßn input(); √¥ Input c√≥ ~${have} d√≤ng ‚Üí thi·∫øu kho·∫£ng ${miss} d√≤ng.`);
      }
      tip("Nh·∫≠p ƒë·ªß s·ªë d√≤ng theo ƒë·ªÅ (m·ªói input() c·∫ßn 1 d√≤ng) ho·∫∑c x√≥a input() th·ª´a.");
      return tips;
    }

    // ========== NameError / UnboundLocalError ==========
    if(t === "NameError"){
      const mm = m.match(/name '([^']+)' is not defined/);
      const name = mm ? mm[1] : "";
      if(name){
        if(["true","false","none"].includes(name.toLowerCase())){
          tip(`B·∫°n vi·∫øt \`${name}\` nh∆∞ng Python d√πng \`True/False/None\` (ch·ªØ c√°i ƒë·∫ßu vi·∫øt hoa).`);
          return tips;
        }
        tip(`B·∫°n d√πng \`${name}\` nh∆∞ng ch∆∞a ƒë∆∞·ª£c t·∫°o (ch∆∞a g√°n gi√° tr·ªã / g√µ sai t√™n).`);
        // N·∫øu in ch·ªØ m√† qu√™n nh√°y
        try{
          const re = new RegExp(`\\bprint\\s*\\(\\s*${_v7_escapeRegExp(name)}\\s*\\)`);
          const hasAssign = new RegExp(`\\b${_v7_escapeRegExp(name)}\\s*=`);
          if(re.test(lineTrim) && !hasAssign.test(code)){
            tip(`N·∫øu b·∫°n mu·ªën in ch·ªØ "${name}": vi·∫øt \`print("${name}")\`.`);
            tip(`N·∫øu "${name}" l√† bi·∫øn: h√£y g√°n \`${name} = ...\` tr∆∞·ªõc khi d√πng.`);
            return tips;
          }
        }catch(e){}
        tip("Ki·ªÉm tra ch√≠nh t·∫£ (Python ph√¢n bi·ªát HOA/th∆∞·ªùng).");
      }else{
        tip("D√πng t√™n bi·∫øn/h√†m ch∆∞a ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a.");
        tip("Ki·ªÉm tra ch√≠nh t·∫£ v√† ƒë·∫£m b·∫£o ƒë√£ g√°n bi·∫øn tr∆∞·ªõc khi d√πng.");
      }
      return tips;
    }
    if(t === "UnboundLocalError"){
      const mm = m.match(/local variable '([^']+)' referenced before assignment/);
      const name = mm ? mm[1] : "";
      if(name){
        tip(`Bi·∫øn c·ª•c b·ªô \`${name}\` ƒë∆∞·ª£c d√πng tr∆∞·ªõc khi g√°n trong h√†m.`);
        tip(`H√£y g√°n \`${name} = ...\` tr∆∞·ªõc khi d√πng (ho·∫∑c d√πng \`global ${name}\` n·∫øu b·∫°n th·∫≠t s·ª± mu·ªën d√πng bi·∫øn to√†n c·ª•c).`);
      }else{
        tip("Bi·∫øn c·ª•c b·ªô ƒë∆∞·ª£c d√πng tr∆∞·ªõc khi g√°n trong h√†m.");
      }
      return tips;
    }

    // ========== ValueError ==========
    if(t === "ValueError"){
      // invalid literal for int() with base 10: 'abc'
      let lit = "";
      let mm = m.match(/invalid literal for int\(\) with base \d+:\s*'([^']*)'/i);
      if(mm) lit = mm[1];
      mm = m.match(/could not convert string to float:\s*'([^']*)'/i);
      if(!lit && mm) lit = mm[1];

      if(lit !== ""){
        if(lit === ""){
          tip("B·∫°n ƒëang √©p ki·ªÉu s·ªë nh∆∞ng d·ªØ li·ªáu nh·∫≠p l√† chu·ªói r·ªóng (d√≤ng tr·ªëng).");
          tip("Ki·ªÉm tra √¥ Input: c√≥ th·ªÉ thi·∫øu d√≤ng ho·∫∑c c√≥ input() th·ª´a.");
        }else{
          tip(`B·∫°n ƒëang √©p ki·ªÉu s·ªë nh∆∞ng d·ªØ li·ªáu nh·∫≠p l√† '${lit}' (kh√¥ng ph·∫£i s·ªë).`);
          tip("N·∫øu c·∫ßn nh·∫≠p ch·ªØ: b·ªè int()/float(). N·∫øu c·∫ßn nh·∫≠p s·ªë: s·ª≠a input cho ƒë√∫ng d·∫°ng s·ªë.");
        }
        return tips;
      }

      if(/not enough values to unpack/i.test(m) || /too many values to unpack/i.test(m)){
        tip("B·∫°n ƒëang t√°ch d·ªØ li·ªáu (split/unpack) nh∆∞ng s·ªë ph·∫ßn t·ª≠ kh√¥ng kh·ªõp.");
        tip("Ki·ªÉm tra input: c√≥ bao nhi√™u gi√° tr·ªã tr√™n 1 d√≤ng v√† b·∫°n ƒëang g√°n cho bao nhi√™u bi·∫øn.");
        return tips;
      }

      tip("ValueError: d·ªØ li·ªáu kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng so v·ªõi c√°ch b·∫°n x·ª≠ l√Ω (√©p ki·ªÉu / split / unpack).");
      return tips;
    }

    // ========== TypeError ==========
    if(t === "TypeError"){
      if(/can only concatenate str/i.test(m) || /unsupported operand type\(s\) for \+:/i.test(m)){
        tip("B·∫°n ƒëang n·ªëi/c·ªông chu·ªói v·ªõi s·ªë (kh√°c ki·ªÉu).");
        tip("S·ª≠a: d√πng f-string (vd: print(f\"...{n}...\")) ho·∫∑c print v·ªõi d·∫•u ph·∫©y (vd: print(\"...\", n)).");
        return tips;
      }
      if(/object is not callable/i.test(m)){
        tip("B·∫°n ƒëang g·ªçi m·ªôt bi·∫øn nh∆∞ h√†m (th·ª´a d·∫•u ngo·∫∑c `()` sau bi·∫øn).");
        tip("Ki·ªÉm tra d√≤ng b√°o l·ªói: b·ªè `()` ho·∫∑c ƒë·ªïi t√™n bi·∫øn n·∫øu b·∫°n v√¥ t√¨nh ƒë√® l√™n t√™n h√†m.");
        return tips;
      }
      if(/cannot be interpreted as an integer/i.test(m)){
        tip("B·∫°n ƒë∆∞a chu·ªói/float v√†o n∆°i c·∫ßn s·ªë nguy√™n (th∆∞·ªùng l√† range()).");
        tip("S·ª≠a: √©p ki·ªÉu `int(...)` tr∆∞·ªõc khi d√πng trong range/loop.");
        return tips;
      }
      if(/takes .* positional arguments but .* were given/i.test(m) || /missing .* required positional argument/i.test(m)){
        tip("B·∫°n g·ªçi h√†m sai s·ªë l∆∞·ª£ng tham s·ªë.");
        tip("ƒê·ªëi chi·∫øu ƒë·ªãnh nghƒ©a `def ...(...):` v√† c√°ch b·∫°n g·ªçi h√†m ·ªü d√≤ng b√°o l·ªói.");
        return tips;
      }
      tip("TypeError: thao t√°c kh√¥ng h·ª£p l·ªá gi·ªØa c√°c ki·ªÉu d·ªØ li·ªáu.");
      tip("H√£y nh√¨n message sau TypeError ƒë·ªÉ bi·∫øt ki·ªÉu n√†o ƒëang b·ªã d√πng sai.");
      return tips;
    }

    // ========== ZeroDivisionError ==========
    if(t === "ZeroDivisionError"){
      tip("B·∫°n ƒëang chia (/) ho·∫∑c chia l·∫•y d∆∞ (%) v·ªõi m·∫´u s·ªë b·∫±ng 0.");
      tip("S·ª≠a: ki·ªÉm tra m·∫´u s·ªë != 0 tr∆∞·ªõc khi chia (if b != 0: ...).");
      return tips;
    }

    // ========== IndexError / KeyError / AttributeError ==========
    if(t === "IndexError"){
      tip("B·∫°n truy c·∫≠p list/chu·ªói v∆∞·ª£t ph·∫°m vi (index ngo√†i 0..len-1).");
      tip("S·ª≠a: ki·ªÉm tra len(...) v√† ƒëi·ªÅu ki·ªán trong v√≤ng l·∫∑p tr∆∞·ªõc khi truy c·∫≠p.");
      return tips;
    }
    if(t === "KeyError"){
      const mm = m.match(/^'([^']*)'$/) || m.match(/KeyError:\s*'([^']*)'/i);
      const key = mm ? mm[1] : "";
      if(key) tip(`Key '${key}' kh√¥ng t·ªìn t·∫°i trong dict.`);
      else tip("Key kh√¥ng t·ªìn t·∫°i trong dict.");
      tip("S·ª≠a: ki·ªÉm tra key (if key in dict) ho·∫∑c d√πng dict.get(key).");
      return tips;
    }
    if(t === "AttributeError"){
      const mm = m.match(/'([^']+)' object has no attribute '([^']+)'/);
      if(mm){
        tip(`B·∫°n ƒëang g·ªçi .${mm[2]} tr√™n m·ªôt ƒë·ªëi t∆∞·ª£ng ki·ªÉu ${mm[1]} (kh√¥ng c√≥ thu·ªôc t√≠nh ƒë√≥).`);
        tip("S·ª≠a: ki·ªÉm tra l·∫°i ki·ªÉu d·ªØ li·ªáu c·ªßa bi·∫øn (type(x)) v√† t√™n h√†m/thu·ªôc t√≠nh.");
        return tips;
      }
      tip("B·∫°n g·ªçi thu·ªôc t√≠nh/h√†m kh√¥ng t·ªìn t·∫°i tr√™n ƒë·ªëi t∆∞·ª£ng.");
      tip("S·ª≠a: ki·ªÉm tra t√™n h√†m/thu·ªôc t√≠nh v√† ki·ªÉu c·ªßa bi·∫øn.");
      return tips;
    }

    // ========== ModuleNotFoundError ==========
    if(t === "ModuleNotFoundError"){
      const mm = m.match(/No module named '([^']+)'/i);
      if(mm) tip(`Kh√¥ng t√¨m th·∫•y module '${mm[1]}'.`);
      tip("Trong m√¥i tr∆∞·ªùng web, kh√¥ng ph·∫£i module n√†o c≈©ng c√≥. H·∫°n ch·∫ø import ngo√†i y√™u c·∫ßu ƒë·ªÅ.");
      return tips;
    }

    // Fallback
    tip("Xem d√≤ng cu·ªëi traceback ƒë·ªÉ bi·∫øt t√™n l·ªói v√† l√Ω do c·ª• th·ªÉ.");
    if(lineNo!=null) tip(`L·ªói ph√°t sinh t·∫°i d√≤ng ${lineNo}: ${lineTrim || _getCodeLine(code, lineNo).trim()}`);
    return tips;
  }

  // Gi·∫£i th√≠ch l·ªói theo ki·ªÉu "Python b√¨nh th∆∞·ªùng" + h∆∞·ªõng d·∫´n s·ª≠a c·ª• th·ªÉ, b√°m s√°t traceback.
  function viExplainByDisease(stderr, code, stdin="", problem=null){
    const clean = _stripJsStack(stderr);
    const {type, msg} = extractErrTypeMsg(clean);

    // Line + column (n·∫øu l√† SyntaxError c√≥ caret)
    const syn = (type === "SyntaxError") ? _v7_parseSyntaxPointerFromTrace(clean) : null;
    const fr  = _v7_parseLastUserFrame(clean);

    let lineNo = syn?.line ?? fr?.line ?? extractLineNoFromTrace(clean);
    let colNo  = syn?.col ?? null;
    let endCol = syn?.endCol ?? null;

    // N·∫øu thi·∫øu lineNo nh∆∞ng c√≥ "(detected at line ...)" (hi·∫øm), d√πng lu√¥n.
    if(lineNo == null){
      const det = _v7_detectedLineFromMsg(msg);
      if(det != null) lineNo = det;
    }

    const lineText = (lineNo!=null) ? _getCodeLine(code, lineNo) : "";
    const lineTrim = String(lineText||"").trim();
    const whereParts = [];
    if(lineNo!=null) whereParts.push(`d√≤ng ${lineNo}`);
    if(colNo!=null) whereParts.push(`c·ªôt ${colNo}`);
    const where = whereParts.length ? `üìç V·ªã tr√≠: ${whereParts.join(", ")}${lineTrim?`  |  ${lineTrim}`:""}` : "";

    const pyHeader = `‚ùå Python b√°o l·ªói: ${type || "Error"}${msg?": "+msg:""}`;
    const around = _v7_buildContext(code, lineNo, colNo, endCol);

    const tips = _v7_buildTips(type, msg, clean, code, stdin, problem, lineNo, colNo, endCol);
    const tipBlock = tips.length ? `‚úÖ G·ª£i √Ω s·ª≠a nhanh:\n${tips.map(x=>"- "+x).join("\n")}` : "";

    return [
      pyHeader,
      where,
      around,
      tipBlock,
      `\nüìå Traceback (Python g·ªëc):\n${clean}`
    ].filter(Boolean).join("\n");
  }


  // =======================
  // Error -> UI (nh·∫•n m·∫°nh ph·∫ßn L·ªñI + g·∫°ch ƒë·ªè ngay trong editor)
  // - Khi ch·∫°y/test b·ªã l·ªói: hi·ªÉn th·ªã l·ªói r√µ r√†ng + g·ª£i √Ω s·ª≠a
  // - ƒê·ªìng th·ªùi g·∫°ch ƒë·ªè ƒë√∫ng d√≤ng l·ªói trong Monaco ƒë·ªÉ HS s·ª≠a nhanh
  // =======================
  function buildPyErrorInfo(stderr, code, stdin="", problem=null){
    const clean = _stripJsStack(stderr);
    const {type, msg} = extractErrTypeMsg(clean);

    // Line + column (n·∫øu l√† SyntaxError c√≥ caret)
    const syn = (type === "SyntaxError") ? _v7_parseSyntaxPointerFromTrace(clean) : null;
    const fr  = _v7_parseLastUserFrame(clean);

    let lineNo = syn?.line ?? fr?.line ?? extractLineNoFromTrace(clean);
    let colNo  = syn?.col ?? null;
    let endCol = syn?.endCol ?? null;

    // N·∫øu thi·∫øu lineNo nh∆∞ng c√≥ "(detected at line ...)" (hi·∫øm)
    if(lineNo == null){
      const det = _v7_detectedLineFromMsg(msg);
      if(det != null) lineNo = det;
    }

    const lineText = (lineNo!=null) ? _getCodeLine(code, lineNo) : "";
    const tips = _v7_buildTips(type, msg, clean, code, stdin, problem, lineNo, colNo, endCol);
    const context = _v7_buildContext(code, lineNo, colNo, endCol);

    return {
      clean,
      type: type || "Error",
      msg: msg || "",
      lineNo, colNo, endCol,
      lineText,
      tips,
      context
    };
  }

  function clearEditorMarkers(){
    try{
      if(window.monaco && editor && editor.getModel){
        monaco.editor.setModelMarkers(editor.getModel(), "py10", []);
      }
    }catch(e){}
  }

  function applyEditorMarkerFromError(info){
    try{
      if(!window.monaco || !editor || !editor.getModel) return;
      const model = editor.getModel();
      if(!model) return;

      clearEditorMarkers();
      if(!info || !info.lineNo) return;

      const ln = Math.max(1, Number(info.lineNo || 1));
      const sc = Math.max(1, Number(info.colNo || 1));
      const ec = info.endCol ? Math.max(sc+1, Number(info.endCol)+1) : (sc+1);

      monaco.editor.setModelMarkers(model, "py10", [{
        startLineNumber: ln,
        startColumn: sc,
        endLineNumber: ln,
        endColumn: ec,
        message: `${info.type || "Error"}${info.msg ? ": " + info.msg : ""}`,
        severity: monaco.MarkerSeverity.Error,
      }]);

      // Cu·ªôn t·ªõi d√≤ng l·ªói ƒë·ªÉ HS th·∫•y ngay
      try{ editor.revealLineInCenter(ln); }catch(_){}
    }catch(e){}
  }

  function renderPyErrorHTML(info, extraNote=""){
    const type = info?.type || "Error";
    const msg = info?.msg || "";
    const lineNo = info?.lineNo;
    const colNo = info?.colNo;
    const lineText = (info?.lineText || "").trim();

    const header = `<div><span class="x">‚ùå Python b√°o l·ªói:</span> <b>${escapeHTML(type)}</b>${msg?`: ${escapeHTML(msg)}`:""}</div>`;

    const where = (lineNo!=null)
      ? `<div class="muted" style="margin-top:6px">üìç V·ªã tr√≠: d√≤ng ${escapeHTML(String(lineNo))}${(colNo!=null)?`, c·ªôt ${escapeHTML(String(colNo))}`:""}${lineText?` ‚Ä¢ <code>${escapeHTML(lineText)}</code>`:""}</div>`
      : `<div class="muted" style="margin-top:6px">üìç Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c d√≤ng l·ªói (h√£y xem Traceback b√™n d∆∞·ªõi).</div>`;

    // Context: t√°ch ti√™u ƒë·ªÅ "üìå Code..." kh·ªèi ph·∫ßn code
    let ctxTitle = "";
    let ctxBody = "";
    try{
      const ctx = String(info?.context || "").replace(/^\n+/, "");
      const parts = ctx.split("\n");
      if(parts.length){
        ctxTitle = parts[0] || "";
        ctxBody = parts.slice(1).join("\n");
      }
    }catch(e){}

    const ctxHtml = ctxBody
      ? `<details open style="margin-top:10px">
           <summary class="muted">${escapeHTML(ctxTitle || "üìå Code quanh d√≤ng l·ªói")}</summary>
           <pre style="white-space:pre-wrap; margin:8px 0 0">${escapeHTML(ctxBody)}</pre>
         </details>`
      : "";

    const tips = (info?.tips || []).filter(Boolean);
    const tipsHtml = tips.length
      ? `<div style="margin-top:10px"><span class="hint">üí° G·ª£i √Ω s·ª≠a nhanh:</span>
           <ul style="margin:6px 0 0 18px; padding:0">${tips.map(t=>`<li>${escapeHTML(t)}</li>`).join("")}</ul>
         </div>`
      : `<div style="margin-top:10px" class="muted">üí° Ch∆∞a c√≥ g·ª£i √Ω t·ª± ƒë·ªông cho l·ªói n√†y. H√£y xem Traceback v√† d√≤ng l·ªói.</div>`;

    const noteHtml = extraNote
      ? `<div class="muted" style="margin-top:10px">${escapeHTML(extraNote)}</div>`
      : "";

    const trace = info?.clean ? String(info.clean) : "";
    const traceHtml = trace
      ? `<details style="margin-top:10px">
           <summary class="muted">Chi ti·∫øt k·ªπ thu·∫≠t (Traceback Python)</summary>
           <pre style="white-space:pre-wrap; margin:8px 0 0">${escapeHTML(trace)}</pre>
         </details>`
      : "";

    const editorTip = `<div class="muted" style="margin-top:10px">üëâ M·∫πo: d√≤ng l·ªói s·∫Ω ƒë∆∞·ª£c g·∫°ch ƒë·ªè trong khung so·∫°n th·∫£o (editor) ƒë·ªÉ b·∫°n s·ª≠a nhanh.</div>`;

    return header + where + tipsHtml + noteHtml + ctxHtml + traceHtml + editorTip;
  }

  // =======================
  // Runner
  // =======================
  // Ch·∫°y code Python v·ªõi input m√¥ ph·ªèng stdin.
  // M·ª•c ti√™u:
  // - B·∫Øt ƒë∆∞·ª£c c·∫£ l·ªói c√∫ ph√°p (SyntaxError) thay v√¨ b·ªã "at wrapper" t·ª´ Pyodide
  // - D√≤ng l·ªói (line X) KH·ªöP v·ªõi d√≤ng trong code c·ªßa h·ªçc sinh
  // - Tr·∫£ v·ªÅ {out, err} d·∫°ng chu·ªói, kh√¥ng quƒÉng exception ra JS trong tr∆∞·ªùng h·ª£p l·ªói Python
    // Runner: ch·∫°y code Python v·ªõi input, lu√¥n tr·∫£ v·ªÅ {out, err} d·∫°ng chu·ªói
  async function runPythonWithInput(code, inputStr){
    if(!pyodide) throw new Error("Pyodide ch∆∞a s·∫µn s√†ng");

    const userCode = (code ?? "").toString();
    const userIn   = (inputStr ?? "").toString();

    // ƒê∆∞a code/input qua globals ƒë·ªÉ tr√°nh l·ªói escape khi nh√∫ng v√†o chu·ªói Python.
    pyodide.globals.set("__USER_CODE__", userCode);
    pyodide.globals.set("__USER_STDIN__", userIn);

    const py = String.raw`
import sys, io, traceback, builtins, contextlib, linecache

code  = globals().get("__USER_CODE__", "")
stdin = globals().get("__USER_STDIN__", "")

FILENAME = "main.py"
# ƒë·ªÉ traceback in ƒë√∫ng d√≤ng code
linecache.cache[FILENAME] = (len(code), None, code.splitlines(True), FILENAME)

_out = io.StringIO()
_err = io.StringIO()

# stdin theo √¥ Input
sys.stdin = io.StringIO(stdin)

# input() gi·ªëng Python th·∫≠t: h·∫øt d·ªØ li·ªáu -> EOFError
def _silent_input(prompt=None):
    s = sys.stdin.readline()
    if s == "":
        raise EOFError("EOF when reading a line")
    return s.rstrip("\n")

builtins.input = _silent_input

ns = {"__name__": "__main__"}

try:
    with contextlib.redirect_stdout(_out), contextlib.redirect_stderr(_err):
        exec(compile(code, FILENAME, "exec"), ns)
except BaseException as e:
    # Format l·ªói gi·ªëng Python ch·∫°y file: ch·ªâ hi·ªÉn th·ªã stack c·ªßa main.py
    if isinstance(e, SyntaxError):
        _err.write(f'  File "{FILENAME}", line {e.lineno}\n')
        if e.text:
            _err.write("    " + e.text.rstrip() + "\n")
            if e.offset:
                off = max(1, int(e.offset))
                end = getattr(e, "end_offset", None)
                if isinstance(end, int) and end > off:
                    carets = "^" * max(1, end - off)
                else:
                    carets = "^"
                _err.write("    " + (" " * (off - 1)) + carets + "\n")
        _err.write(f"{e.__class__.__name__}: {e.msg}\n")
    else:
        tb = traceback.TracebackException.from_exception(e)
        stack = [fr for fr in tb.stack if fr.filename == FILENAME]
        _err.write("Traceback (most recent call last):\n")
        for fr in stack:
            _err.write(f'  File "{fr.filename}", line {fr.lineno}, in {fr.name}\n')
            if fr.line:
                _err.write(f"    {fr.line}\n")
        for line in tb.format_exception_only():
            _err.write(line)

__out = _out.getvalue()
__err = _err.getvalue()
`;

    try{
      await pyodide.runPythonAsync(py);
    }catch(e){
      // Fallback: n·∫øu Pyodide n√©m l·ªói ra JS, ∆∞u ti√™n message (th∆∞·ªùng ch·ª©a traceback)
      let raw = (e && (e.message || e.stack)) ? String(e.message || e.stack) : String(e);
      const idx = raw.indexOf("Traceback (most recent call last):");
      if(idx >= 0) raw = raw.slice(idx);
      return { out: "", err: raw };
    }

    // L·∫•y k·∫øt qu·∫£ (∆∞u ti√™n string) + tr√°nh r√≤ r·ªâ PyProxy
    let out = "";
    let err = "";
    try{
      const outP = pyodide.globals.get("__out");
      const errP = pyodide.globals.get("__err");
      out = (outP == null) ? "" : String(outP);
      err = (errP == null) ? "" : String(errP);
      if(outP && typeof outP.destroy === "function") outP.destroy();
      if(errP && typeof errP.destroy === "function") errP.destroy();
    }catch(e){
      err = String(e);
    }

    return { out, err };
  }

  async function gradeProblem(problem, code){
    const allTests = [
      ...(problem.tests.public||[]).map(t=>({...t,__public:true})),
      ...(problem.tests.hidden||[]).map(t=>({...t,__public:false}))
    ];
    let passCount=0;
    for(let i=0;i<allTests.length;i++){
      const t=allTests[i];
      const {out,err}=await runPythonWithInput(code,t.input);
      if(err && err.trim()){
        return { pass:false, runtimeError:true, passCount, total:allTests.length, failedAt:i+1, out, err, test:t };
      }
      let ok=false;
      ok = problem.checker ? problem.checker(out,t.expected,t.input,t) : (tokenize(out).join(" ")===tokenize(String(t.expected)).join(" "));
      if(!ok){
        return { pass:false, runtimeError:false, passCount, total:allTests.length, failedAt:i+1, out, err:"", test:t };
      }
      passCount++;
    }
    return { pass:true, runtimeError:false, passCount:allTests.length, total:allTests.length, failedAt:null };
  }

  // =======================
  // Hint engine
  // =======================
  function chooseHintLevel(problem){
    const code = getCode().trim();
    const nonEmpty = code ? code.split("\n").filter(l=>l.trim()).length : 0;
    const dangling = hasDanglingBlock(code);
    if(!dangling.ok) return 5;
    if(state.lastRunHadError) return 5;
    if(!code || nonEmpty<2 || code.length<25) return 1;
    if(state.runCount===0) return 2;
    if(!state.lastRunPassed) return (state.failStreak>=2 ? 4 : 3);
    return 1;
  }
  function pickHint(problem, level){
    const arr = (problem.hints && problem.hints["level"+level]) ? problem.hints["level"+level] : [];
    return arr.length ? arr[Math.floor(Math.random()*arr.length)] : "Ch∆∞a c√≥ g·ª£i √Ω cho m·ª©c n√†y.";
  }

  // =======================
  // G·ª£i √Ω khi FAIL (kh√¥ng ƒë∆∞a l·ªùi gi·∫£i ho√†n ch·ªânh, ch·ªâ ch·ªâ ra ch·ªó HAY SAI)
  // =======================
  function suggestFailReason(problem, code){
    const id = (problem && problem.id) ? problem.id : "";
    const c = String(code || "");
    const hasInput = /\binput\s*\(/.test(c);
    const hasPrint = /\bprint\s*\(/.test(c);
    const hasIf = /\bif\b/.test(c);
    const hasElif = /\belif\b/.test(c);
    const hasElse = /\belse\b/.test(c);
    const hasLoop = /\bfor\b/.test(c) || /\bwhile\b/.test(c);
    const hasMod  = /%/.test(c);

    const tips = [];
    switch(id){
      case "b01":
        if(!hasPrint) tips.push("B·∫°n c·∫ßn print(...) ƒë·ªÉ in ra k·∫øt qu·∫£.");
        tips.push('In ƒë√∫ng chu·ªói: "Hello, world!" (ƒë√∫ng d·∫•u c√¢u).');
        break;

      case "b02":
        if(!hasInput) tips.push("B·∫°n c·∫ßn ƒë·ªçc n b·∫±ng input().");
        if(!hasPrint) tips.push("B·∫°n c·∫ßn print(n) (ho·∫∑c bi·∫øn ch·ª©a n).");
        tips.push("Kh√¥ng c·∫ßn in th√™m ch·ªØ, ch·ªâ in ƒë√∫ng s·ªë.");
        break;

      case "b03":
        if(!hasInput) tips.push("B·∫°n c·∫ßn ƒë·ªçc t√™n v√† nƒÉm sinh b·∫±ng input().");
        tips.push("Tu·ªïi = nƒÉm hi·ªán t·∫°i ‚àí nƒÉm sinh.");
        tips.push("In ra c√≥ c·∫£ t√™n v√† tu·ªïi (ƒë√∫ng ƒë·ªãnh d·∫°ng).");
        break;

      case "b04":
        tips.push("Chu vi P = 2*(a+b), di·ªán t√≠ch S = a*b.");
        tips.push("Nh·ªõ in ƒë·ªß 2 s·ªë (P v√† S).");
        break;

      case "b05":
        tips.push("T√≠nh trung b√¨nh: (a+b+c)/3.");
        tips.push('In l√†m tr√≤n 2 ch·ªØ s·ªë th·∫≠p ph√¢n (round(x,2) ho·∫∑c f"{x:.2f}").');
        break;

      case "b06":
        if(!hasMod) tips.push("Ch·∫µn/l·∫ª: d√πng n % 2.");
        if(!(hasIf && hasElse)) tips.push("C·∫ßn if/else ƒë·ªÉ in 2 tr∆∞·ªùng h·ª£p.");
        tips.push('In ƒë√∫ng ch·ªØ "chan" ho·∫∑c "le".');
        break;

      case "b07":
        if(!hasIf) tips.push("C·∫ßn if ƒë·ªÉ ki·ªÉm tra n < 0.");
        tips.push('N·∫øu √¢m in "la so am", ng∆∞·ª£c l·∫°i in "khong phai la so am".');
        break;

      case "b08":
        if(!hasMod) tips.push("Chia h·∫øt: d√πng n % 3 == 0 v√† n % 5 == 0.");
        if(!hasIf) tips.push("C·∫ßn if ƒë·ªÉ ph√¢n bi·ªát chia h·∫øt/kh√¥ng chia h·∫øt.");
        tips.push('In ƒë√∫ng ch·ªØ "chia het" ho·∫∑c "khong chia het".');
        break;

      case "b09":
        if(!hasIf) tips.push("C·∫ßn if ƒë·ªÉ ki·ªÉm tra ƒëi·ªÅu ki·ªán t·∫°o tam gi√°c.");
        tips.push("ƒêi·ªÅu ki·ªán: a+b>c, a+c>b, b+c>a.");
        tips.push('In ƒë√∫ng 1 trong 2 c√¢u theo ƒë·ªÅ.');
        break;

      case "b10":
        if(!(hasIf && (hasElif || hasElse))) tips.push("B√†i ti·ªÅn ƒëi·ªán c√≥ nhi·ªÅu m·ª©c ‚Üí c·∫ßn if/elif/else.");
        tips.push("ƒê∆°n gi√°: 1678 (<=50), 1734 (51..100), 2014 (>100).");
        tips.push("Ki·ªÉm tra ƒë√∫ng bi√™n kWh = 50 v√† kWh = 100.");
        break;

      case "b11":
        if(!hasLoop) tips.push("C·∫ßn v√≤ng l·∫∑p ƒë·ªÉ in 10 d√≤ng.");
        tips.push('M·ªói d√≤ng ch·ªâ in ƒë√∫ng ch·ªØ "hello". Kh√¥ng in th√™m ch·ªØ kh√°c.');
        break;

      case "b12":
        if(!hasLoop) tips.push("C·∫ßn v√≤ng l·∫∑p ƒë·ªÉ in t·ª´ 1 ƒë·∫øn 100.");
        tips.push("range ƒë√∫ng: range(1, 101).");
        break;

      case "b13":
        if(!hasLoop) tips.push("C·∫ßn v√≤ng l·∫∑p ƒë·ªÉ in c√°c s·ªë ch·∫µn < 100.");
        tips.push("G·ª£i √Ω range: range(2, 100, 2).");
        break;

      case "b14":
        if(!hasLoop) tips.push("C·∫ßn v√≤ng l·∫∑p ƒë·ªÉ duy·ªát t·ª´ a ƒë·∫øn b.");
        if(!hasMod) tips.push("ƒêi·ªÅu ki·ªán: i % 3 == 0 v√† i % 5 == 0.");
        tips.push("Nh·ªõ bao g·ªìm c·∫£ b (range(a, b+1)).");
        break;

      case "b15":
        if(!hasLoop) tips.push("C·∫ßn v√≤ng l·∫∑p 1..n ƒë·ªÉ t√¨m ∆∞·ªõc.");
        if(!hasMod) tips.push("∆Ø·ªõc: n·∫øu n % i == 0 th√¨ i l√† ∆∞·ªõc.");
        tips.push("Nh·ªõ in t·∫•t c·∫£ ∆∞·ªõc, v√† cu·ªëi c√πng in th√™m S·ªê L∆Ø·ª¢NG ∆∞·ªõc (d√≤ng cu·ªëi).");
        break;

      case "b16":
        tips.push("S·ªë nguy√™n t·ªë: n<2 l√† KH√îNG nguy√™n t·ªë.");
        tips.push("Duy·ªát i t·ª´ 2 ƒë·∫øn sqrt(n): n·∫øu n % i == 0 ‚Üí kh√¥ng nguy√™n t·ªë.");
        tips.push('In "la so nguyen to" ho·∫∑c "khong phai la so nguyen to".');
        break;

      case "b17":
        if(!hasLoop) tips.push("C·∫ßn while ƒë·ªÉ c·ªông d·∫ßn cho t·ªõi khi t·ªïng > 100.");
        tips.push("Nh·ªõ tƒÉng i v√† c·ªông v√†o t·ªïng m·ªói v√≤ng.");
        tips.push("Ch·ªâ in t·ªïng cu·ªëi c√πng.");
        break;

      case "b18":
        if(!hasLoop) tips.push("C·∫ßn while ƒë·ªÉ sinh d√£y 1,4,7,... ƒë·∫øn khi <=100.");
        tips.push("D·ª´ng khi s·ªë ti·∫øp theo s·∫Ω >100, r·ªìi in s·ªë hi·ªán t·∫°i.");
        break;

      case "b19":
        if(!hasLoop) tips.push("C·∫ßn v√≤ng l·∫∑p 0..99.");
        if(!hasMod) tips.push("S·ªë ch·∫µn: i % 2 == 0.");
        tips.push("In 2 s·ªë: t·ªïng c√°c s·ªë ch·∫µn v√† s·ªë l∆∞·ª£ng s·ªë ch·∫µn.");
        break;

      case "b20":
        tips.push("ƒê·∫øm ch·ªØ s·ªë: l·∫∑p n//=10 v√† tƒÉng ƒë·∫øm (ho·∫∑c d√πng len(str(n))).");
        tips.push("Nh·ªõ n>0 theo ƒë·ªÅ.");
        break;

      case "b21":
        tips.push("ƒê·∫£o ch·ªØ s·ªë: l·∫•y digit=n%10 r·ªìi gh√©p rev=rev*10+digit.");
        tips.push("Ch√∫ √Ω s·ªë c√≥ s·ªë 0 ·ªü cu·ªëi (v√≠ d·ª• 100) ‚Üí ƒë·∫£o ra 1.");
        break;

      default:
        tips.push("Ki·ªÉm tra ƒëi·ªÅu ki·ªán bi√™n v√† ƒë·ªãnh d·∫°ng output (kho·∫£ng tr·∫Øng / xu·ªëng d√≤ng).");
        break;
    }
    return tips.join(" ");
  }


  // =======================
  // Render + events
  // =======================
    // =======================
  // B√†i l·ªõn / B√†i nh·ªè (chia nh√≥m ƒë·ªÉ kh√¥ng x·ªï 21 b√†i m·ªôt l·∫ßn)
  // - M·∫∑c ƒë·ªãnh c√≥ 4 b√†i l·ªõn: V√†o/ra, if, for, while
  // - N·∫øu c√≥ b√†i GV giao, t·ª± th√™m nh√≥m "B√†i GV giao"
  // =======================
  let GROUPS = [];

  function rebuildGroups(){
    const order = [
      {id:"io",    short:"M·ª•c 1", title:"M·ª•c 1: V√†o/ra ƒë∆°n gi·∫£n"},
      {id:"if",    short:"M·ª•c 2", title:"M·ª•c 2: C√¢u l·ªánh if"},
      {id:"for",   short:"M·ª•c 3", title:"M·ª•c 3: V√≤ng l·∫∑p for"},
      {id:"while", short:"M·ª•c 4", title:"M·ª•c 4: V√≤ng l·∫∑p while"},
    ];

    const buckets = new Map(order.map(o=>[o.id, []]));
    const extras = [];

    for(const p of PROBLEMS){
      const g = p.group || "";
      if(buckets.has(g)){
        buckets.get(g).push(p);
      }else{
        extras.push(p); // b√†i GV giao / b√†i kh√¥ng thu·ªôc 4 nh√≥m
      }
    }

    const res = [];
    for(const o of order){
      const items = buckets.get(o.id) || [];
      if(items.length) res.push({ id:o.id, shortTitle: (o.short||o.title), title:o.title, items });
    }
    if(extras.length){
      res.push({ id:"gv", shortTitle:"GV", title:"B√†i GV giao", items: extras });
    }
    GROUPS = res;
    return res;
  }

  function groupOfProblemId(pid){
    for(const g of GROUPS){
      if((g.items||[]).some(p=>p.id===pid)) return g.id;
    }
    return GROUPS.length ? GROUPS[0].id : null;
  }

  function firstUnlockedInGroup(groupId, progress){
    const g = GROUPS.find(x=>x.id===groupId);
    if(!g) return null;
    for(const p of (g.items||[])){
      if(isUnlockedById(p.id, progress)) return p.id;
    }
    return null;
  }

  function renderGroupSelect(){
    if(!elGroup) return;
    rebuildGroups();
    elGroup.innerHTML = GROUPS.map(g=>`<option value="${g.id}">${escapeHTML(g.title)}</option>`).join("");
  }

  function renderProblemSelect(groupId){
    if(!elSelect) return;
    const g = GROUPS.find(x=>x.id===groupId) || GROUPS[0];
    const progress = loadProgress();
    const items = (g && g.items) ? g.items : [];
    elSelect.innerHTML = items.map((p)=>{
      const idx = indexOfProblem(p.id);
      const unlocked = isUnlockedByIndex(idx, progress);
      const passed = !!(progress.passed && progress.passed[p.id]);
      const label = `${p.title}${passed ? " ‚úÖ" : (unlocked ? "" : " üîí")}`;
      return `<option value="${p.id}" ${unlocked ? "" : "disabled"}>${escapeHTML(label)}</option>`;
    }).join("");
  }

  
  function groupShortTitle(gid){
    const g = GROUPS.find(x=>x.id===gid);
    if(g) return (g.shortTitle || g.title || gid);
    // Fallback: map theo id nh√≥m
    if(gid === "io") return "M·ª•c 1";
    if(gid === "if") return "M·ª•c 2";
    if(gid === "for") return "M·ª•c 3";
    if(gid === "while") return "M·ª•c 4";
    if(gid === "gv") return "GV giao";
    return String(gid||"");
  }

  function updateGroupOverlay(){
    if(!elGroup || !elGroupOverlay) return;
    const gid = elGroup.value;
    elGroupOverlay.textContent = groupShortTitle(gid);
  }

function syncPickersToCurrent(){
    renderGroupSelect();
    if(!GROUPS.length) rebuildGroups();

    const gid = groupOfProblemId(state.currentId) || (GROUPS[0] && GROUPS[0].id);
    if(elGroup && gid) elGroup.value = gid;
    updateGroupOverlay();

    renderProblemSelect(gid);
    if(elSelect) elSelect.value = state.currentId;
  }

  function gotoProblemById(desiredId, {silent=false} = {}){
    if(!GROUPS.length) rebuildGroups();
    const progress = loadProgress();
    if(!isUnlockedById(desiredId, progress)){
      if(!silent){
        setOutHTML(
          `<span class="x">üîí B√†i n√†y ƒëang b·ªã kh√≥a.</span>\n`+
          `<span class="hint">B·∫°n c·∫ßn PASS b√†i tr∆∞·ªõc r·ªìi m·ªõi m·ªü b√†i ti·∫øp theo.</span>`
        );
      }
      return false;
    }

    // Tr√°nh l·ªói "l·∫´n b√†i": n·∫øu HS v·ª´a g√µ v√† ƒë·ªïi b√†i nhanh (<250ms), timer auto-save
    // c√≥ th·ªÉ save nh·∫ßm sang b√†i m·ªõi. V√¨ v·∫≠y: flush save ngay tr∆∞·ªõc khi ƒë·ªïi b√†i.
    try{
      if(saveTimer){ clearTimeout(saveTimer); saveTimer = null; }
      if(editor && state && state.currentId){
        saveCode(state.currentId, getCode());
      }
    }catch(e){}

    const gid = groupOfProblemId(desiredId) || (GROUPS[0] && GROUPS[0].id);
    if(elGroup && gid) elGroup.value = gid;
    updateGroupOverlay();

    renderProblemSelect(gid);

    state.currentId = desiredId;
    state.lastSelectableId = desiredId;
    if(elSelect) elSelect.value = desiredId;

    renderProblem(currentProblem());
    return true;
  }

  function initSelect(){
    syncPickersToCurrent();
  }

  function renderProblem(p){
    elSubtitle.textContent = p.statement;
    elStatementTitle.textContent = p.title;
    elStatementText.textContent = p.statement;

    // Khi chuy·ªÉn sang b√†i m·ªõi: KH√îNG t·ª± n·∫°p khung.
    // - N·∫øu HS ƒë√£ c√≥ code ƒë√£ l∆∞u (c√≥ d√≤ng code th·∫≠t) th√¨ t·∫£i l·∫°i.
    // - N·∫øu ch∆∞a c√≥ code (ho·∫∑c ch·ªâ l∆∞u m·ªói khung/comment) th√¨ ƒë·ªÉ tr·ªëng.
    const saved = loadSavedCode(p.id);
    const useSaved = (saved !== null && saved.trim() !== "" && !_isOnlySavedScaffold(saved));
    setCode(useSaved ? saved : "");

    elStdin.value = p.sampleInput||"";
    state.hintClicks=0; state.lastRunHadError=false; state.lastRunPassed=false; state.lastErrText=""; state.failStreak=0; state.runCount=0;

    // M·∫∑c ƒë·ªãnh ·∫©n n√∫t "B√†i ti·∫øp theo" (ch·ªâ hi·ªán khi PASS).
    if(elNext) elNext.style.display = 'none';

    setPill("Ch∆∞a ch·∫°y","");
    setOutHTML(`<span class="muted">Ch∆∞a ch·∫°y.</span>`);

    const total=(p.tests.public.length+p.tests.hidden.length);
    elScoreMeta.textContent=`Test: 0/${total}`;

    updateCoach();
      applyPretestGate();
  }


  // =======================
  // Events: B√†i l·ªõn / B√†i nh·ªè
  // =======================
  if(elGroup){
    elGroup.addEventListener("change", ()=>{
      const gid = elGroup.value;
      const progress = loadProgress();

      const curG = groupOfProblemId(state.currentId);
      const keepCurrent = (curG === gid) && isUnlockedById(state.currentId, progress);

      const first = firstUnlockedInGroup(gid, progress);
      if(!first){
        // Nh√≥m n√†y ch∆∞a m·ªü: quay l·∫°i nh√≥m hi·ªán t·∫°i
        if(curG) elGroup.value = curG;
        updateGroupOverlay();
        setOutHTML(
          `<span class="x">üîí B√†i l·ªõn n√†y ƒëang b·ªã kh√≥a.</span>\n`+
          `<span class="hint">B·∫°n c·∫ßn PASS b√†i tr∆∞·ªõc r·ªìi m·ªõi m·ªü b√†i ti·∫øp theo.</span>`
        );
        return;
      }

      const target = keepCurrent ? state.currentId : first;
      gotoProblemById(target, {silent:true});
    });
  }

  if(elSmallBtn){
    elSmallBtn.addEventListener("click", ()=>{
      try{ elSelect.focus(); elSelect.click(); }catch(e){}
    });
  }

  elSelect.addEventListener("change",()=>{
    const desiredId = elSelect.value;
    const ok = gotoProblemById(desiredId, {silent:false});
    if(!ok){
      // Quay l·∫°i b√†i g·∫ßn nh·∫•t c√≥ th·ªÉ ch·ªçn
      elSelect.value = state.lastSelectableId;
    }
  });

  elLoad.addEventListener("click",()=>{
    const p=currentProblem();
    const cur = getCode().trim();
    if(cur){
      if(!confirm("N·∫°p khung s·∫Ω ghi ƒë√® ph·∫ßn ƒëang vi·∫øt. B·∫°n c√≥ ch·∫Øc?")) return;
    }
    setCode(p.starter);
    setOutHTML(`<span class="hint">üí° ƒê√£ n·∫°p khung (kh√¥ng c√≥ code m·∫´u).</span>`);
    debounceCoach(0);
  });

  elHint.addEventListener("click",()=>{
    const p=currentProblem();
    if(state.hintClicks>=state.maxHint){
      setOutHTML(`<span class="hint">üí° B·∫°n ƒë√£ d√πng h·∫øt g·ª£i √Ω.</span>\n<span class="muted">H√£y xem checklist v√† s·ª≠a t·ª´ng b∆∞·ªõc.</span>`);
      return;
    }

    state.hintClicks++;

    // Level g·ª£i √Ω: tƒÉng d·∫ßn theo s·ªë l·∫ßn b·∫•m (1‚Üí5),
    // nh∆∞ng n·∫øu b·∫°n v·ª´a g·∫∑p l·ªói / thi·∫øu c·∫•u tr√∫c th√¨ t·ª± n√¢ng l√™n ƒë·ªÉ g·ª£i √Ω "ƒë√∫ng tr·ªçng t√¢m".
    let level = Math.min(state.hintClicks, state.maxHint);
    const autoLevel = chooseHintLevel(p);
    level = Math.min(state.maxHint, Math.max(level, autoLevel));

    const live = liveCoachHint(getCode(), getCursorOffset(), elStdin.value);
    if(live){
      setOutHTML(
        `<span class="hint">üí° G·ª£i √Ω t·ª©c th√¨</span>\n\n`+
        `${escapeHTML(live.message)}`+
        `<div class="muted" style="margin-top:8px">üëâ M·∫πo: nh·∫•n <b>Ctrl + Space</b> ƒë·ªÉ hi·ªán g·ª£i √Ω code trong editor.</div>`
      );
      return;
    }

    const hint = pickHint(p, level);
    const more =
      (level < state.maxHint)
        ? `<div class="muted" style="margin-top:8px">üëâ B·∫•m <b>G·ª£i √Ω</b> th√™m l·∫ßn n·ªØa ƒë·ªÉ l√™n Level ${level+1}.</div>`
        : `<div class="muted" style="margin-top:8px">B·∫°n ƒëang ·ªü Level cao nh·∫•t.</div>`;

    setOutHTML(
      `<span class="hint">üí° G·ª£i √Ω Level ${level}/${state.maxHint}</span>\n\n`+
      `${escapeHTML(hint)}`+
      more+
      `<div class="muted" style="margin-top:6px">üí° N·∫øu v·∫´n FAIL: h√£y ch·∫°y <b>Ch·∫°y th·ª≠</b> ƒë·ªÉ xem output, r·ªìi ch·ªânh l·∫°i theo ƒë√∫ng ƒë·ªãnh d·∫°ng.</div>`
    );
  });
  if(elRunOnly){
    elRunOnly.addEventListener("click", async ()=>{
      const p=currentProblem();
      const code=getCode();
      const stdin=elStdin.value;

      clearEditorMarkers();
      setPill("ƒêang ch·∫°y...","");
      setOutHTML(`<span class="muted">ƒêang ch·∫°y th·ª≠ v·ªõi Input...</span>`);
      elRunOnly.disabled=true;

      try{
        const trial = await runPythonWithInput(code, stdin);
        if(trial.err && trial.err.trim()){
          state.lastRunHadError=true; state.lastRunPassed=false; state.failStreak++;
          const info = buildPyErrorInfo(trial.err || "", code, stdin, p);
          state.lastErrText = (info.type || "Error") + (info.msg ? (": " + info.msg) : "") + (info.lineNo ? (" (d√≤ng " + info.lineNo + ")") : "");
          setPill("L·ªói khi ch·∫°y","bad");
          applyEditorMarkerFromError(info);
          setOutHTML(renderPyErrorHTML(info));
        }else{
          state.lastRunHadError=false; state.lastErrText="";
          clearEditorMarkers();
          const out = normalizeOutput(trial.out);
          setPill("Ch·∫°y xong","ok");
          setOutHTML(`<span class="ok">‚ñ∂ Output (ch·∫°y th·ª≠)</span>\n\n${escapeHTML(out || "(Kh√¥ng c√≥ output)")}`);
        }
        updateCoach();
      }catch(e){
        setPill("L·ªói h·ªá th·ªëng","bad");
        setOutHTML(formatSystemError(e, getCode()));
        updateCoach();
      }finally{
        syncGateControls();
      }
    });
  }


  elRun.addEventListener("click", async ()=>{
    const p=currentProblem();
    const code=getCode();
    const stdin=elStdin.value;

    clearEditorMarkers();
    setPill("ƒêang test...","");
    setOutHTML(`<span class="muted">ƒêang ch·∫°y test case...</span>`);
    elRun.disabled=true;

    try{
      state.runCount++;

      const grade = await gradeProblem(p, code);
      elScoreMeta.textContent = `Test: ${grade.passCount}/${grade.total}`;

      // N·∫øu runtime error x·∫£y ra ·ªü 1 test (k·ªÉ c·∫£ hidden), hi·ªÉn th·ªã ƒë√∫ng l·ªói thay v√¨ gom v√†o FAIL chung chung.
      if(grade && grade.runtimeError){
        state.lastRunHadError=true; state.lastRunPassed=false; state.failStreak++;
        const where = grade.failedAt ? ` (test #${grade.failedAt})` : "";
        setPill("L·ªói khi ch·∫°y"+where, "bad");
        const safeIn = (grade.test && grade.test.__public) ? (grade.test.input||"") : "";
        const info = buildPyErrorInfo(grade.err || "", code, safeIn, p);
        let extra = "";
        if(grade.test && !grade.test.__public){
          extra = "‚ÑπÔ∏è L·ªói x·∫£y ra ·ªü test ·∫©n (hidden). H·ªá th·ªëng kh√¥ng hi·ªÉn th·ªã input c·ªßa test n√†y, nh∆∞ng d√≤ng l·ªói trong code c·ªßa b·∫°n l√† ch√≠nh x√°c.";
        }
        state.lastErrText = (info.type || "Error") + (info.msg ? (": " + info.msg) : "") + (info.lineNo ? (" (d√≤ng " + info.lineNo + ")") : "");
        applyEditorMarkerFromError(info);
        setOutHTML(renderPyErrorHTML(info, extra));
        syncTeacherResult({ lessonId: p.id, ok: false, err: grade.err || "", act: "test", code, stdin, stdout: "" });
        updateCoach();
        return;
      }

      if(grade.pass){
        state.lastRunPassed=true; state.lastRunHadError=false; state.failStreak=0;
        setPill("PASS ‚úÖ","ok");
        setOutHTML(
          `<span class="ok">‚úÖ PASS</span>  <span class="muted">(ƒê√∫ng theo test case)</span>\n\n`+
          `<span class="muted">üëâ Mu·ªën xem output v·ªõi d·ªØ li·ªáu b·∫°n nh·∫≠p: b·∫•m <b>Ch·∫°y th·ª≠</b>.</span>`
        );

        const prog = loadProgress();
        prog.passed = prog.passed || {};
        prog.passed[p.id] = true;
        saveProgress(prog);
        // ƒê·ªìng b·ªô PASS l√™n b·∫£ng K·∫øt qu·∫£ c·ªßa GV
        syncTeacherResult({ lessonId: p.id, ok: true, err: "", act: "test", code, stdin, stdout: "" });
        state.lastErrText = "";

        initSelect();
        state.lastSelectableId = state.currentId;

        // PASS: KH√îNG t·ª± nh·∫£y b√†i. Ch·ªâ hi·ªán n√∫t "B√†i ti·∫øp theo" ƒë·ªÉ h·ªçc sinh b·∫•m.
        const nextId = findNextUnlockedId();
        if(nextId && elNext){
          elNext.style.display = 'inline-flex';
          elNext.disabled = false;
          elNext.onclick = () => {
            elNext.style.display = 'none';
            gotoProblemById(nextId, {silent:true});
          };
        } else if(elNext){
          elNext.style.display = 'none';
        }

      } else {
        state.lastRunPassed=false; state.lastRunHadError=false; state.failStreak++;
        setPill("FAIL ‚ùå","bad");

        const dangling = hasDanglingBlock(code);
        let reason = "";
        if(!dangling.ok){
          reason = `B·∫°n ƒëang thi·∫øu th√¢n kh·ªëi sau ':' (d√≤ng ${dangling.line}). H√£y th·ª•t l·ªÅ v√† vi·∫øt l·ªánh trong nh√°nh ƒë√≥.`;
        } else {
          reason = suggestFailReason(p, code);
        }

        // N·∫øu tr∆∞·ª£t test, hi·ªÉn th·ªã output c·ªßa test ƒëang tr∆∞·ª£t (n·∫øu c√≥) ƒë·ªÉ HS s·ª≠a ƒë√∫ng ch·ªó.
        const failOut  = (grade && grade.out != null) ? normalizeOutput(grade.out) : "";
        const shownOut = failOut || "(Kh√¥ng c√≥ output)";
        const isPublicTest = !!(grade && grade.test && grade.test.__public);
        const testLabel = isPublicTest ? "c√¥ng khai" : "·∫©n";

        let compareBox = "";
        try{
          if(grade && grade.test){
            if(isPublicTest){
              const inp = String(grade.test.input ?? "");
              const exp = normalizeOutput(String(grade.test.expected ?? "")).trimEnd();
              const got = String(shownOut ?? "");
              compareBox =
                `\n\n<details style="margin-top:10px">`+
                `<summary class="muted">So s√°nh v·ªõi Expected (test ${testLabel})</summary>`+
                `<pre style="white-space:pre-wrap; margin:8px 0 0">`+
                `${escapeHTML("INPUT:\n"+inp+"\nEXPECTED:\n"+exp+"\n\nOUTPUT C·ª¶A B·∫†N:\n"+got)}`+
                `</pre></details>`;
            }else{
              compareBox =
                `\n\n<span class="muted">‚ÑπÔ∏è Test #${grade.failedAt} l√† test ·∫©n (hidden) n√™n kh√¥ng hi·ªÉn th·ªã input/expected. H√£y ki·ªÉm tra ƒëi·ªÅu ki·ªán bi√™n v√† ƒë·ªãnh d·∫°ng output.</span>`;
            }
          }
        }catch(e){ compareBox = ""; }

        setOutHTML(
          `<span class="x">‚ùå FAIL</span> <span class="muted">(Tr∆∞·ª£t ·ªü test #${grade.failedAt} ‚Ä¢ ${testLabel})</span>\n`+
          `<span class="hint">üí° G·ª£i √Ω s·ª≠a nh·∫π:</span> ${escapeHTML(reason)}\n\n`+
          `${escapeHTML(shownOut)}`+
          compareBox
        );
        state.lastErrText = `FAIL test #${grade.failedAt}. ${reason}`;
        // ƒê·ªìng b·ªô FAIL l√™n b·∫£ng K·∫øt qu·∫£ c·ªßa GV
        syncTeacherResult({ lessonId: p.id, ok: false, err: state.lastErrText, act: "test", code, stdin, stdout: "" });
      }

      updateCoach();

    } catch(e){
      setPill("L·ªói h·ªá th·ªëng","bad");
      setOutHTML(formatSystemError(e, getCode()));
      updateCoach();
    } finally {
      syncGateControls();
    }
  });

  // =======================
  // Boot
  // =======================
  function bootUI(){
    const progress = loadProgress();
    if(!isUnlockedById(state.currentId, progress)) state.currentId = PROBLEMS[0].id;
    state.lastSelectableId = state.currentId;

    initSelect();
    if(elSelect) elSelect.value = state.currentId;

    renderProblem(currentProblem());
  }

  function enableUIReady(){
    ENGINE_READY = true;
    elStatus.textContent="S·∫µn s√†ng";
    setPill("Ch∆∞a ch·∫°y","");
    // Enable/disable theo tr·∫°ng th√°i √¥n luy·ªán
    applyPretestGate();
    syncGateControls();
    updateCoach();
  }

  require.config({ paths: { vs: "https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs" } });

  require(["vs/editor/editor.main"], async function () {
    editor = monaco.editor.create(document.getElementById("editor"), {
      // Kh√¥ng t·ª± n·∫°p "khung" khi v·ª´a m·ªü trang / v·ª´a chuy·ªÉn b√†i.
      // N·ªôi dung s·∫Ω ƒë∆∞·ª£c renderProblem(...) n·∫°p l·∫°i (code ƒë√£ l∆∞u ho·∫∑c ƒë·ªÉ tr·ªëng).
      value: "",
      language: "python",
      theme: "vs",
      automaticLayout: true,
      minimap: { enabled: false },
      fontSize: 14,
      lineHeight: 21,
      fontFamily: 'ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace',
      scrollBeyondLastLine: false,
      wordWrap: "off",
      tabSize: 4,
      insertSpaces: true,
      // G·ª£i √Ω khi g√µ (nh·∫•n Ctrl+Space ƒë·ªÉ hi·ªán danh s√°ch)
      quickSuggestions: { other: true, comments: false, strings: true },
      suggestOnTriggerCharacters: true,
      tabCompletion: "on",
      snippetSuggestions: "inline",
      acceptSuggestionOnEnter: "on",
      autoClosingBrackets: "always",
      autoClosingQuotes: "always",
      autoIndent: "advanced",
    });

    monaco.languages.registerCompletionItemProvider("python", {
      // G·ª£i √Ω code (Ctrl+Space). B·∫≠t snippet ƒë·ªÉ HS ch√®n khung nhanh.
      triggerCharacters: [" ", "(", ".", ":"],
      provideCompletionItems: function(model, position) {
        const word = model.getWordUntilPosition(position);
        const range = {
          startLineNumber: position.lineNumber,
          endLineNumber: position.lineNumber,
          startColumn: word.startColumn,
          endColumn: word.endColumn
        };

        const suggestions = AC_WORDS.map(w => ({
          label: w.label,
          kind: monaco.languages.CompletionItemKind.Snippet,
          insertText: w.insertText,
          insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
          detail: w.detail,
          range
        }));
        return { suggestions };
      }
    });

    editor.onDidChangeModelContent(() => {
      scheduleSave();
      // S·ª≠a code th√¨ xo√° g·∫°ch ƒë·ªè c≈© ƒë·ªÉ tr√°nh hi·ªÉu nh·∫ßm
      clearEditorMarkers();
      debounceCoach(120);
    });

    editor.onDidChangeCursorPosition(() => {
      debounceCoach(0);
    });

    
  // Expose snapshot for outer shell (help tickets)
  window.__py10GetSnapshot = function(){
    try{
      const p = (typeof currentProblem === "function") ? currentProblem() : null;
      return {
        lessonId: (state && state.currentId) ? state.currentId : "",
        lessonTitle: p && p.title ? p.title : "",
        code: (typeof getCode === "function") ? getCode() : "",
        lastError: (state && state.lastErrText) ? state.lastErrText : "",
        lastStatus: (state && state.lastStatusText) ? state.lastStatusText : "",
        lastOutput: (typeof getOutputText === "function") ? getOutputText() : "",
      };
    } catch(e){
      return { lessonId:"", lessonTitle:"", code:"", lastError:String(e||""), lastStatus:"", lastOutput:"" };
    }
  };

  function getOutputText(){
    try{
      const el = document.getElementById("out");
      if(!el) return "";
      return (el.innerText || "").trim();
    }catch(e){ return ""; }
  }

bootUI();


    // =======================
    // B√†i GV giao: t·ª± c·∫≠p nh·∫≠t danh s√°ch (khi GV v·ª´a giao/ s·ª≠a ƒë·ªÅ)
    // =======================
    let __lastAssignRaw = "";
    let __lastBankRaw = "";
    try{
      __lastAssignRaw = localStorage.getItem(ASSIGN_KEY) || "";
      __lastBankRaw = localStorage.getItem(TEACHER_BANK_KEY) || "";
    }catch(e){}

    function refreshAssignedProblems(){
      try{
        const aRaw = localStorage.getItem(ASSIGN_KEY) || "";
        const bRaw = localStorage.getItem(TEACHER_BANK_KEY) || "";
        if(aRaw === __lastAssignRaw && bRaw === __lastBankRaw) return;
        __lastAssignRaw = aRaw;
        __lastBankRaw = bRaw;

        // L∆∞u nh√°p ƒë·ªÉ kh√¥ng m·∫•t ƒëo·∫°n ƒëang g√µ
        try{ saveCode(state.currentId, getCode()); }catch(_){}

        const curId = state.currentId;
        rebuildProblemsFromAssignments();

        // Gi·ªØ nguy√™n b√†i ƒëang l√†m n·∫øu c√≤n t·ªìn t·∫°i, ng∆∞·ª£c l·∫°i ch·ªçn b√†i h·ª£p l·ªá g·∫ßn nh·∫•t
        if(PROBLEMS.some(p=>p.id===curId)){
          state.currentId = curId;
          state.lastSelectableId = curId;
        }else{
          const progress = loadProgress();
          let fallback = PROBLEMS[0].id;
          for(const p of PROBLEMS){
            if(isUnlockedById(p.id, progress)){ fallback = p.id; break; }
          }
          state.currentId = fallback;
          state.lastSelectableId = fallback;
        }

        initSelect();
        // ƒê·ªìng b·ªô ƒë√∫ng nh√≥m + b√†i nh·ªè, v√† render ƒë·ªÅ
        gotoProblemById(state.currentId, {silent:true});
      }catch(err){
        console.warn("refreshAssignedProblems failed", err);
      }
    }

    // storage event: khi GV thao t√°c ·ªü tab kh√°c
    try{
      window.addEventListener("storage", (e)=>{
        if(!e) return;
        if(e.key === ASSIGN_KEY || e.key === TEACHER_BANK_KEY){
          setTimeout(refreshAssignedProblems, 80);
        }
      });
    }catch(e){}

    // Poll nh·∫π: khi m·ªôt s·ªë tr√¨nh duy·ªát/tab kh√¥ng b·∫Øn event
    setInterval(()=>{ try{ refreshAssignedProblems(); }catch(e){} }, 1500);

    elStatus.textContent="ƒêang t·∫£i Python...";
    setPill("ƒêang t·∫£i...","");
    try{
      pyodide = await loadPyodide();
      enableUIReady();
    }catch(e){
      console.error("loadPyodide failed", e);
      elStatus.textContent="Kh√¥ng t·∫£i ƒë∆∞·ª£c Python";
      setPill("L·ªói t·∫£i Python","bad");
      const msg =
        "Kh√¥ng n·∫°p ƒë∆∞·ª£c Pyodide (Python) ‚Äî c√≥ th·ªÉ do m·∫°ng, AdBlock ho·∫∑c ch·∫∑n CDN.\n\n"+
        "G·ª£i √Ω:\n"+
        "- Th·ª≠ t·∫Øt AdBlock/ti·ªán √≠ch ch·∫∑n script\n"+
        "- Th·ª≠ m·ªü b·∫±ng HTTPS (GitHub Pages) thay v√¨ file:///\n"+
        "- Th·ª≠ ƒë·ªïi m·∫°ng ho·∫∑c tr√¨nh duy·ªát\n\n"+
        "Chi ti·∫øt: " + (e && e.message ? e.message : String(e));
      setOutHTML(`<span class="x">${escapeHTML(msg)}</span>`);
    }
  });
</script>

</body>
</html>
